var documenterSearchIndex = {"docs":
[{"location":"Benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"Benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"a = rand(Vec{3})\nA = rand(SecondOrderTensor{3})\nS = rand(SymmetricSecondOrderTensor{3})\nB = rand(Tensor{Tuple{3,3,3}})\nAA = rand(FourthOrderTensor{3})\nSS = rand(SymmetricFourthOrderTensor{3})","category":"page"},{"location":"Benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Operation Tensor Array speed-up\nSingle contraction   \na ⋅ a 1.800 ns 16.133 ns ×9.0\nA ⋅ a 2.900 ns 83.009 ns ×28.6\nS ⋅ a 2.900 ns 84.029 ns ×29.0\nDouble contraction   \nA ⊡ A 3.701 ns 19.861 ns ×5.4\nS ⊡ S 2.600 ns 19.961 ns ×7.7\nB ⊡ A 8.000 ns 248.781 ns ×31.1\nAA ⊡ A 12.112 ns 274.432 ns ×22.7\nSS ⊡ S 6.600 ns 274.513 ns ×41.6\nTensor product   \na ⊗ a 4.100 ns 58.176 ns ×14.2\nCross product   \na × a 4.100 ns 58.176 ns ×14.2\nDeterminant   \ndet(A) 2.200 ns 294.236 ns ×133.7\ndet(S) 2.500 ns 288.783 ns ×115.5\nInverse   \ninv(A) 9.309 ns 855.605 ns ×91.9\ninv(S) 6.900 ns 743.731 ns ×107.8\ninv(AA) 1.620 μs 2.400 μs ×1.5\ninv(SS) 536.390 ns 2.456 μs ×4.6","category":"page"},{"location":"Benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The benchmarks are generated by runbenchmarks.jl on the following system:","category":"page"},{"location":"Benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"julia> versioninfo()\nJulia Version 1.7.2\nCommit bf53498635 (2022-02-06 15:21 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Xeon(R) CPU E5-2673 v3 @ 2.40GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-12.0.1 (ORCJIT, haswell)\n","category":"page"},{"location":"Einstein summation/","page":"Einstein summation","title":"Einstein summation","text":"DocTestSetup = :(using Tensorial)","category":"page"},{"location":"Einstein summation/#Einstein-summation","page":"Einstein summation","title":"Einstein summation","text":"","category":"section"},{"location":"Einstein summation/","page":"Einstein summation","title":"Einstein summation","text":"Order = [:type, :function, :macro]\nPages = [\"Einstein summation.md\"]","category":"page"},{"location":"Einstein summation/","page":"Einstein summation","title":"Einstein summation","text":"Modules = [Tensorial]\nOrder   = [:type, :function, :macro]\nPages   = [\"einsum.jl\"]","category":"page"},{"location":"Einstein summation/#Tensorial.@einsum-Tuple{Any}","page":"Einstein summation","title":"Tensorial.@einsum","text":"@einsum (i,j...) -> expr\n@einsum expr\n\nConducts tensor computation based on Einstein summation convention. The arguments of the anonymous function are regard as free indices. If arguments are not given, they are guessed based on the order that indices appears from left to right.\n\nExamples\n\njulia> A = rand(Mat{3,3})\n3×3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> B = rand(Mat{3,3})\n3×3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.748415  0.00744801  0.682533\n 0.578232  0.199377    0.956741\n 0.727935  0.439243    0.647855\n\njulia> @einsum (i,j) -> A[i,k] * B[k,j]\n3×3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 1.45486   0.599373  1.69554\n 1.19421   0.42393   1.22798\n 0.751346  0.297329  0.846595\n\njulia> @einsum A[i,k] * B[k,j] # same as above\n3×3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 1.45486   0.599373  1.69554\n 1.19421   0.42393   1.22798\n 0.751346  0.297329  0.846595\n\njulia> @einsum A[i,j] * B[i,j]\n2.7026716125808266\n\n\n\n\n\n","category":"macro"},{"location":"Tensor Operations/","page":"Tensor Operations","title":"Tensor Operations","text":"DocTestSetup = :(using Tensorial)","category":"page"},{"location":"Tensor Operations/#Tensor-Operations","page":"Tensor Operations","title":"Tensor Operations","text":"","category":"section"},{"location":"Tensor Operations/","page":"Tensor Operations","title":"Tensor Operations","text":"Order = [:function]\nPages = [\"Tensor Operations.md\"]","category":"page"},{"location":"Tensor Operations/","page":"Tensor Operations","title":"Tensor Operations","text":"Modules = [Tensorial]\nOrder   = [:function]\nPages   = [\"ops.jl\"]","category":"page"},{"location":"Tensor Operations/#LinearAlgebra.cross-Union{Tuple{T2}, Tuple{T1}, Tuple{Vec{1, T1}, Vec{1, T2}}} where {T1, T2}","page":"Tensor Operations","title":"LinearAlgebra.cross","text":"cross(x::Vec{3}, y::Vec{3}) -> Vec{3}\ncross(x::Vec{2}, y::Vec{2}) -> Vec{3}\ncross(x::Vec{1}, y::Vec{1}) -> Vec{3}\nx × y\n\nCompute the cross product between two vectors. The vectors are expanded to 3D frist for dimensions 1 and 2. The infix operator × (written \\times) can also be used. x × y (where × can be typed by \\times<tab>) is a synonym for cross(x, y).\n\nExamples\n\njulia> x = rand(Vec{3})\n3-element Vec{3, Float64}:\n 0.32597672886359486\n 0.5490511363155669\n 0.21858665481883066\n\njulia> y = rand(Vec{3})\n3-element Vec{3, Float64}:\n 0.8942454282009883\n 0.35311164439921205\n 0.39425536741585077\n\njulia> x × y\n3-element Vec{3, Float64}:\n  0.13928086435138393\n  0.0669520417303531\n -0.37588028973385323\n\n\n\n\n\n","category":"method"},{"location":"Tensor Operations/#LinearAlgebra.dot-Tuple{AbstractTensor, AbstractTensor}","page":"Tensor Operations","title":"LinearAlgebra.dot","text":"dot(x::AbstractTensor, y::AbstractTensor)\nx ⋅ y\n\nCompute dot product such as a = x_i y_i. This is equivalent to contraction(::AbstractTensor, ::AbstractTensor, Val(1)). x ⋅ y (where ⋅ can be typed by \\cdot<tab>) is a synonym for dot(x, y).\n\nExamples\n\njulia> x = rand(Vec{3})\n3-element Vec{3, Float64}:\n 0.32597672886359486\n 0.5490511363155669\n 0.21858665481883066\n\njulia> y = rand(Vec{3})\n3-element Vec{3, Float64}:\n 0.8942454282009883\n 0.35311164439921205\n 0.39425536741585077\n\njulia> a = x ⋅ y\n0.5715585109976284\n\n\n\n\n\n","category":"method"},{"location":"Tensor Operations/#LinearAlgebra.norm-Tuple{AbstractTensor}","page":"Tensor Operations","title":"LinearAlgebra.norm","text":"norm(::AbstractTensor)\n\nCompute norm of a tensor.\n\nExamples\n\njulia> x = rand(Mat{3, 3})\n3×3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> norm(x)\n1.8223398556552728\n\n\n\n\n\n","category":"method"},{"location":"Tensor Operations/#LinearAlgebra.tr-Tuple{Union{AbstractSymmetricSecondOrderTensor{dim, T}, AbstractMat{dim, dim, T}} where {dim, T}}","page":"Tensor Operations","title":"LinearAlgebra.tr","text":"tr(::AbstractSecondOrderTensor)\ntr(::AbstractSymmetricSecondOrderTensor)\n\nCompute the trace of a square tensor.\n\nExamples\n\njulia> x = rand(Mat{3,3})\n3×3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> tr(x)\n1.1733382401532275\n\n\n\n\n\n","category":"method"},{"location":"Tensor Operations/#Tensorial.contraction-Union{Tuple{N}, Tuple{AbstractTensor, AbstractTensor, Val{N}}} where N","page":"Tensor Operations","title":"Tensorial.contraction","text":"contraction(::AbstractTensor, ::AbstractTensor, ::Val{N})\n\nConduct contraction of N inner indices. For example, N=2 contraction for third-order tensors A_ij = B_ikl C_klj can be computed in Tensorial.jl as\n\njulia> B = rand(Tensor{Tuple{3,3,3}});\n\njulia> C = rand(Tensor{Tuple{3,3,3}});\n\njulia> A = contraction(B, C, Val(2))\n3×3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 3.70978  2.47156  3.91807\n 2.90966  2.30881  3.25965\n 1.78391  1.38714  2.2079\n\nFollowing symbols are also available for specific contractions:\n\nx ⊗ y (where ⊗ can be typed by \\otimes<tab>): contraction(x, y, Val(0))\nx ⋅ y (where ⋅ can be typed by \\cdot<tab>): contraction(x, y, Val(1))\nx ⊡ y (where ⊡ can be typed by \\boxdot<tab>): contraction(x, y, Val(2))\n\n\n\n\n\n","category":"method"},{"location":"Tensor Operations/#Tensorial.otimes-Tuple{AbstractTensor, AbstractTensor}","page":"Tensor Operations","title":"Tensorial.otimes","text":"otimes(x::AbstractTensor, y::AbstractTensor)\nx ⊗ y\n\nCompute tensor product such as A_ij = x_i y_j. x ⊗ y (where ⊗ can be typed by \\otimes<tab>) is a synonym for otimes(x, y).\n\nExamples\n\njulia> x = rand(Vec{3})\n3-element Vec{3, Float64}:\n 0.32597672886359486\n 0.5490511363155669\n 0.21858665481883066\n\njulia> y = rand(Vec{3})\n3-element Vec{3, Float64}:\n 0.8942454282009883\n 0.35311164439921205\n 0.39425536741585077\n\njulia> A = x ⊗ y\n3×3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.291503  0.115106   0.128518\n 0.490986  0.193876   0.216466\n 0.19547   0.0771855  0.086179\n\n\n\n\n\n","category":"method"},{"location":"Tensor Operations/#Tensorial.rotate-Tuple{Vec, Tensor{Tuple{dim, dim}, T, 2} where {dim, T}}","page":"Tensor Operations","title":"Tensorial.rotate","text":"rotate(x::Vec, R::SecondOrderTensor)\nrotate(x::SecondOrderTensor, R::SecondOrderTensor)\nrotate(x::SymmetricSecondOrderTensor, R::SecondOrderTensor)\n\nRotate x by rotation matrix R. This function can hold the symmetry of SymmetricSecondOrderTensor.\n\nExamples\n\njulia> A = rand(SymmetricSecondOrderTensor{3})\n3×3 SymmetricSecondOrderTensor{3, Float64, 6}:\n 0.325977  0.549051  0.218587\n 0.549051  0.894245  0.353112\n 0.218587  0.353112  0.394255\n\njulia> R = rotmatz(π/4)\n3×3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.707107  -0.707107  0.0\n 0.707107   0.707107  0.0\n 0.0        0.0       1.0\n\njulia> rotate(A, R)\n3×3 SymmetricSecondOrderTensor{3, Float64, 6}:\n  0.0610599  -0.284134  -0.0951235\n -0.284134    1.15916    0.404252\n -0.0951235   0.404252   0.394255\n\njulia> R ⋅ A ⋅ R'\n3×3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n  0.0610599  -0.284134  -0.0951235\n -0.284134    1.15916    0.404252\n -0.0951235   0.404252   0.394255\n\n\n\n\n\n","category":"method"},{"location":"Tensor Operations/#Tensorial.rotmat-Tuple{Number, Vec{3}}","page":"Tensor Operations","title":"Tensorial.rotmat","text":"rotmat(θ, n::Vec)\n\nConstruct rotation matrix from angle θ and axis n.\n\nExamples\n\njulia> x = Vec(1.0, 0.0, 0.0)\n3-element Vec{3, Float64}:\n 1.0\n 0.0\n 0.0\n\njulia> n = Vec(0.0, 0.0, 1.0)\n3-element Vec{3, Float64}:\n 0.0\n 0.0\n 1.0\n\njulia> rotmat(π/2, n) ⋅ x\n3-element Vec{3, Float64}:\n 1.1102230246251565e-16\n 1.0\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"Tensor Operations/#Tensorial.rotmat-Tuple{Number}","page":"Tensor Operations","title":"Tensorial.rotmat","text":"rotmat(θ::Number)\n\nConstruct 2D rotation matrix.\n\nbmR = beginbmatrix\ncostheta  -sintheta \nsintheta   costheta\nendbmatrix\n\nExamples\n\njulia> rotmat(deg2rad(30))\n2×2 Tensor{Tuple{2, 2}, Float64, 2, 4}:\n 0.866025  -0.5\n 0.5        0.866025\n\n\n\n\n\n","category":"method"},{"location":"Tensor Operations/#Tensorial.rotmat-Tuple{Vec{3}}","page":"Tensor Operations","title":"Tensorial.rotmat","text":"rotmat(θ::Vec{3}; sequence::Symbol)\n\nConvert Euler angles to rotation matrix. Use 3 characters belonging to the set (X, Y, Z) for intrinsic rotations, or (x, y, z) for extrinsic rotations.\n\nExamples\n\njulia> α, β, γ = map(deg2rad, rand(3));\n\njulia> rotmat(Vec(α,β,γ), sequence = :XYZ) ≈ rotmatx(α) ⋅ rotmaty(β) ⋅ rotmatz(γ)\ntrue\n\njulia> rotmat(Vec(α,β,γ), sequence = :xyz) ≈ rotmatz(γ) ⋅ rotmaty(β) ⋅ rotmatx(α)\ntrue\n\njulia> rotmat(Vec(α,β,γ), sequence = :XYZ) ≈ rotmat(Vec(γ,β,α), sequence = :zyx)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Tensor Operations/#Tensorial.rotmat-Union{Tuple{Pair{Vec{dim, T}, Vec{dim, T}}}, Tuple{T}, Tuple{dim}} where {dim, T}","page":"Tensor Operations","title":"Tensorial.rotmat","text":"rotmat(a => b)\n\nConstruct rotation matrix rotating vector a to b. The norms of two vectors must be the same.\n\nExamples\n\njulia> a = normalize(rand(Vec{3}))\n3-element Vec{3, Float64}:\n 0.4829957515506539\n 0.8135223859352438\n 0.3238771859304809\n\njulia> b = normalize(rand(Vec{3}))\n3-element Vec{3, Float64}:\n 0.8605677447967596\n 0.3398133016944055\n 0.3794075336718636\n\njulia> R = rotmat(a => b)\n3×3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n -0.00540771   0.853773   0.520617\n  0.853773    -0.267108   0.446905\n  0.520617     0.446905  -0.727485\n\njulia> R ⋅ a ≈ b\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Tensor Operations/#Tensorial.rotmatx-Tuple{Number}","page":"Tensor Operations","title":"Tensorial.rotmatx","text":"rotmatx(θ::Number)\n\nConstruct rotation matrix around x axis.\n\nbmR_x = beginbmatrix\n1  0  0 \n0  costheta  -sintheta \n0  sintheta   costheta\nendbmatrix\n\n\n\n\n\n","category":"method"},{"location":"Tensor Operations/#Tensorial.rotmaty-Tuple{Number}","page":"Tensor Operations","title":"Tensorial.rotmaty","text":"rotmaty(θ::Number)\n\nConstruct rotation matrix around y axis.\n\nbmR_y = beginbmatrix\ncostheta  0  sintheta \n0  1  0 \n-sintheta  0  costheta\nendbmatrix\n\n\n\n\n\n","category":"method"},{"location":"Tensor Operations/#Tensorial.rotmatz-Tuple{Number}","page":"Tensor Operations","title":"Tensorial.rotmatz","text":"rotmatz(θ::Number)\n\nConstruct rotation matrix around z axis.\n\nbmR_z = beginbmatrix\ncostheta  -sintheta  0 \nsintheta   costheta  0 \n0  0  1\nendbmatrix\n\n\n\n\n\n","category":"method"},{"location":"Tensor Operations/#Tensorial.skew-Tuple{AbstractTensor{Tuple{dim, dim}, T, 2} where {dim, T}}","page":"Tensor Operations","title":"Tensorial.skew","text":"skew(::AbstractSecondOrderTensor)\nskew(::AbstractSymmetricSecondOrderTensor)\n\nCompute skew-symmetric (anti-symmetric) part of a second order tensor.\n\n\n\n\n\n","category":"method"},{"location":"Tensor Operations/#Tensorial.skew-Tuple{Vec{3}}","page":"Tensor Operations","title":"Tensorial.skew","text":"skew(ω::Vec{3})\n\nConstruct a skew-symmetric (anti-symmetric) tensor W from a vector ω as\n\nbmomega = beginBmatrix\n    omega_1 \n    omega_2 \n    omega_3\nendBmatrix quad\nbmW = beginbmatrix\n     0          -omega_3   omega_2 \n     omega_3  0           -omega_1 \n    -omega_2   omega_1   0\nendbmatrix\n\nExamples\n\njulia> skew(Vec(1,2,3))\n3×3 Tensor{Tuple{3, 3}, Int64, 2, 9}:\n  0  -3   2\n  3   0  -1\n -2   1   0\n\n\n\n\n\n","category":"method"},{"location":"Quaternion/","page":"Quaternion","title":"Quaternion","text":"DocTestSetup = :(using Tensorial)","category":"page"},{"location":"Quaternion/#Quaternion","page":"Quaternion","title":"Quaternion","text":"","category":"section"},{"location":"Quaternion/","page":"Quaternion","title":"Quaternion","text":"Order = [:type, :function]\nPages = [\"Quaternion.md\"]","category":"page"},{"location":"Quaternion/","page":"Quaternion","title":"Quaternion","text":"Modules = [Tensorial]\nOrder   = [:type, :function]\nPages   = [\"quaternion.jl\"]","category":"page"},{"location":"Quaternion/#Tensorial.Quaternion","page":"Quaternion","title":"Tensorial.Quaternion","text":"Quaternion represents q_w + q_x bmi + q_y bmj + q_z bmk. The salar part and vector part can be accessed by q.scalar and q.vector, respectively.\n\nExamples\n\njulia> Quaternion(1,2,3,4)\n1 + 2𝙞 + 3𝙟 + 4𝙠\n\njulia> Quaternion(1)\n1 + 0𝙞 + 0𝙟 + 0𝙠\n\njulia> Quaternion(Vec(1,2,3))\n0 + 1𝙞 + 2𝙟 + 3𝙠\n\nSee also quaternion.\n\nnote: Note\nQuaternion is experimental and could change or disappear in future versions of Tensorial.\n\n\n\n\n\n","category":"type"},{"location":"Quaternion/#Base.exp-Tuple{Quaternion}","page":"Quaternion","title":"Base.exp","text":"exp(::Quaternion)\n\nCompute the exponential of quaternion as\n\nexp(q) = e^q_w left( cos bmv  + fracbmv bmv  sin bmv  right)\n\n\n\n\n\n","category":"method"},{"location":"Quaternion/#Base.log-Tuple{Quaternion}","page":"Quaternion","title":"Base.log","text":"log(::Quaternion)\n\nCompute the logarithm of quaternion as\n\nln(q) = ln q  + fracbmv bmv  arccosfracq_w q \n\n\n\n\n\n","category":"method"},{"location":"Quaternion/#Tensorial.quaternion-Union{Tuple{T}, Tuple{Type{T}, Real, Vec{3}}} where T","page":"Quaternion","title":"Tensorial.quaternion","text":"quaternion(θ, n::Vec; normalize = true)\n\nConstruct Quaternion from angle θ and axis n as\n\nq = cosfractheta2 + bmn sinfractheta2\n\nThe constructed quaternion is normalized such as norm(q) ≈ 1 by default.\n\nExamples\n\njulia> q = quaternion(π/4, Vec(0,0,1))\n0.9238795325112867 + 0.0𝙞 + 0.0𝙟 + 0.3826834323650898𝙠\n\njulia> x = rand(Vec{3})\n3-element Vec{3, Float64}:\n 0.32597672886359486\n 0.5490511363155669\n 0.21858665481883066\n\njulia> (q * x / q).vector ≈ rotmatz(π/4) ⋅ x\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Quaternion/#Tensorial.rotate-Tuple{Vec, Quaternion}","page":"Quaternion","title":"Tensorial.rotate","text":"rotate(x::Vec, q::Quaternion)\n\nRotate x by quaternion q.\n\nExamples\n\njulia> v = Vec(1.0, 0.0, 0.0)\n3-element Vec{3, Float64}:\n 1.0\n 0.0\n 0.0\n\njulia> rotate(v, quaternion(π/4, Vec(0,0,1)))\n3-element Vec{3, Float64}:\n 0.7071067811865475\n 0.7071067811865476\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"Quaternion/#Tensorial.rotmat-Tuple{Quaternion}","page":"Quaternion","title":"Tensorial.rotmat","text":"rotmat(::Quaternion)\n\nConstruct rotation matrix from quaternion.\n\nExamples\n\njulia> q = quaternion(π/4, Vec(0,0,1))\n0.9238795325112867 + 0.0𝙞 + 0.0𝙟 + 0.3826834323650898𝙠\n\njulia> rotmat(q)\n3×3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.707107  -0.707107  0.0\n 0.707107   0.707107  0.0\n 0.0        0.0       1.0\n\n\n\n\n\n","category":"method"},{"location":"Tensor Type/#Tensor-type","page":"Tensor type","title":"Tensor type","text":"","category":"section"},{"location":"Tensor Type/#Type-parameters","page":"Tensor type","title":"Type parameters","text":"","category":"section"},{"location":"Tensor Type/","page":"Tensor type","title":"Tensor type","text":"All tensors are represented by a type Tensor{S, T, N, L} where each type parameter represents following:","category":"page"},{"location":"Tensor Type/","page":"Tensor type","title":"Tensor type","text":"S: The size of Tensors which is specified by using Tuple (e.g., 3x2 tensor becomes Tensor{Tuple{3,2}}).\nT: The type of element which must be T <: Real.\nN: The number of dimensions (the order of tensor).\nL: The number of independent components.","category":"page"},{"location":"Tensor Type/","page":"Tensor type","title":"Tensor type","text":"Basically, the type parameters N and L do not need to be specified for constructing tensors because it can be inferred from the size of tensor S.","category":"page"},{"location":"Tensor Type/#Symmetry","page":"Tensor type","title":"Symmetry","text":"","category":"section"},{"location":"Tensor Type/","page":"Tensor type","title":"Tensor type","text":"If possible, specifying the symmetry of the tensor is good for performance since Tensorial.jl provides the optimal computations. The symmetries can be applied using Symmetry in type parameter S (e.g., Symmetry{Tuple{3,3}}). @Symmetry macro can omit Tuple like @Symmetry{2,2}. The following are examples to specify symmetries:","category":"page"},{"location":"Tensor Type/","page":"Tensor type","title":"Tensor type","text":"A_(ij) with 3x3: Tensor{Tuple{@Symmetry{3,3}}}\nA_(ij)k with 3x3x2: Tensor{Tuple{@Symmetry{3,3}, 2}}\nA_(ijk) with 3x3x3: Tensor{Tuple{@Symmetry{3,3,3}}}\nA_(ij)(kl) with 3x3x3x3: Tensor{Tuple{@Symmetry{3,3}, @Symmetry{3,3}}}","category":"page"},{"location":"Tensor Type/","page":"Tensor type","title":"Tensor type","text":"where the bracket () in indices denotes the symmetry.","category":"page"},{"location":"Cheat Sheet/#Cheat-Sheet","page":"Cheat Sheet","title":"Cheat Sheet","text":"","category":"section"},{"location":"Cheat Sheet/#Constructors","page":"Cheat Sheet","title":"Constructors","text":"","category":"section"},{"location":"Cheat Sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"# identity tensors\none(Tensor{Tuple{3,3}})            == Matrix(1I,3,3) # second-order identity tensor\none(Tensor{Tuple{@Symmetry{3,3}}}) == Matrix(1I,3,3) # symmetric second-order identity tensor\nI  = one(Tensor{NTuple{4,3}})               # fourth-order identity tensor\nIs = one(Tensor{NTuple{2, @Symmetry{3,3}}}) # symmetric fourth-order identity tensor\n\n# zero tensors\nzero(Mat{2,3}) == zeros(2, 3)\nzero(Tensor{Tuple{@Symmetry{3,3}}}) == zeros(3, 3)\n\n# random tensors\nrand(Mat{2,3})\nrandn(Mat{2,3})\n\n# from arrays\nMat{2,2}([1 2; 3 4]) == [1 2; 3 4]\nTensor{Tuple{@Symmetry{2,2}}}([1 2; 3 4]) == [1 3; 3 4] # lower triangular part is used\n\n# from functions\nMat{2,2}((i,j) -> i == j ? 1 : 0) == one(Mat{2,2})\nTensor{Tuple{@Symmetry{2,2}}}((i,j) -> i == j ? 1 : 0) == one(Tensor{Tuple{@Symmetry{2,2}}})\n\n# macros (same interface as StaticArrays.jl)\n@Vec [1,2,3]\n@Vec rand(4)\n@Mat [1 2\n      3 4]\n@Mat rand(4,4)\n@Tensor rand(2,2,2)\n\n# statically sized getindex by `@Tensor`\nx = @Mat [1 2\n          3 4\n          5 6]\n@Tensor(x[2:3, :])   == @Mat [3 4\n                              5 6]\n@Tensor(x[[1,3], :]) == @Mat [1 2\n                              5 6]","category":"page"},{"location":"Cheat Sheet/#Tensor-Operations","page":"Cheat Sheet","title":"Tensor Operations","text":"","category":"section"},{"location":"Cheat Sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"# 2nd-order vs. 2nd-order\nx = rand(Mat{2,2})\ny = rand(Tensor{Tuple{@Symmetry{2,2}}})\nx ⊗ y isa Tensor{Tuple{2,2,@Symmetry{2,2}}} # tensor product\nx ⋅ y isa Tensor{Tuple{2,2}}                # single contraction (x_ij * y_jk)\nx ⊡ y isa Real                              # double contraction (x_ij * y_ij)\n\n# 3rd-order vs. 1st-order\nA = rand(Tensor{Tuple{@Symmetry{2,2},2}})\nv = rand(Vec{2})\nA ⊗ v isa Tensor{Tuple{@Symmetry{2,2},2,2}} # A_ijk * v_l\nA ⋅ v isa Tensor{Tuple{@Symmetry{2,2}}}     # A_ijk * v_k\nA ⊡ v # error\n\n# 4th-order vs. 2nd-order\nII = one(SymmetricFourthOrderTensor{2}) # equal to one(Tensor{Tuple{@Symmetry{2,2}, @Symmetry{2,2}}})\nA = rand(Mat{2,2})\nS = rand(Tensor{Tuple{@Symmetry{2,2}}})\nII ⊡ A == (A + A') / 2 == symmetric(A) # symmetrizing A, resulting in Tensor{Tuple{@Symmetry{2,2}}}\nII ⊡ S == S\n\n# contraction\nx = rand(Tensor{Tuple{2,2,2}})\ny = rand(Tensor{Tuple{2,@Symmetry{2,2}}})\ncontraction(x, y, Val(1)) isa Tensor{Tuple{2,2, @Symmetry{2,2}}}     # single contraction (== ⋅)\ncontraction(x, y, Val(2)) isa Tensor{Tuple{2,2}}                     # double contraction (== ⊡)\ncontraction(x, y, Val(3)) isa Real                                   # triple contraction (x_ijk * y_ijk)\ncontraction(x, y, Val(0)) isa Tensor{Tuple{2,2,2,2, @Symmetry{2,2}}} # tensor product (== ⊗)\n\n# norm/tr/mean/vol/dev\nx = rand(SecondOrderTensor{3}) # equal to rand(Tensor{Tuple{3,3}})\nv = rand(Vec{3})\nnorm(v)\ntr(x)\nmean(x) == tr(x) / 3 # useful for computing mean stress\nvol(x) + dev(x) == x # decomposition into volumetric part and deviatoric part\n\n# det/inv for 2nd-order tensor\nA = rand(SecondOrderTensor{3})          # equal to one(Tensor{Tuple{3,3}})\nS = rand(SymmetricSecondOrderTensor{3}) # equal to one(Tensor{Tuple{@Symmetry{3,3}}})\ndet(A); det(S)\ninv(A) ⋅ A ≈ one(A)\ninv(S) ⋅ S ≈ one(S)\n\n# inv for 4th-order tensor\nAA = rand(FourthOrderTensor{3})          # equal to one(Tensor{Tuple{3,3,3,3}})\nSS = rand(SymmetricFourthOrderTensor{3}) # equal to one(Tensor{Tuple{@Symmetry{3,3}, @Symmetry{3,3}}})\ninv(AA) ⊡ AA ≈ one(AA)\ninv(SS) ⊡ SS ≈ one(SS)\n\n# Einstein summation convention\nA = rand(Mat{3,3})\nB = rand(Mat{3,3})\n@einsum (i,j) -> A[i,k] * B[k,j]\n@einsum A[i,j] * B[i,j]","category":"page"},{"location":"Cheat Sheet/#Automatic-differentiation","page":"Cheat Sheet","title":"Automatic differentiation","text":"","category":"section"},{"location":"Cheat Sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"# Real -> Real\ngradient(x -> 2x^2 + x + 3, 3) == (x = 3; 4x + 1)\ngradient(x -> 2.0, 3) == 0.0\n\n# Real -> Tensor\ngradient(x -> Mat{2,2}((i,j) -> i*x^2), 3) == (x = 3; Mat{2,2}((i,j) -> 2i*x))\ngradient(x -> one(Mat{2,2}), 3) == zero(Mat{2,2})\n\n# Tensor -> Real\ngradient(tr, rand(Mat{3,3})) == one(Mat{3,3})\n\n# Tensor -> Tensor\nA = rand(Mat{3,3})\nD  = gradient(dev, A)            # deviatoric projection tensor\nDs = gradient(dev, symmetric(A)) # symmetric deviatoric projection tensor\nA ⊡ D  ≈ dev(A)\nA ⊡ Ds ≈ symmetric(dev(A))\ngradient(identity, A) == one(FourthOrderTensor{3})                     # 4th-order identity tensor\ngradient(identity, symmetric(A)) == one(SymmetricFourthOrderTensor{3}) # symmetric 4th-order identity tensor","category":"page"},{"location":"Cheat Sheet/#Aliases","page":"Cheat Sheet","title":"Aliases","text":"","category":"section"},{"location":"Cheat Sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"const Vec{dim, T} = Tensor{Tuple{dim}, T, 1, dim}\nconst Mat{m, n, T, L} = Tensor{Tuple{m, n}, T, 2, L}\nconst SecondOrderTensor{dim, T, L} = Tensor{NTuple{2, dim}, T, 2, L}\nconst FourthOrderTensor{dim, T, L} = Tensor{NTuple{4, dim}, T, 4, L}\nconst SymmetricSecondOrderTensor{dim, T, L} = Tensor{Tuple{@Symmetry{dim, dim}}, T, 2, L}\nconst SymmetricFourthOrderTensor{dim, T, L} = Tensor{NTuple{2, @Symmetry{dim, dim}}, T, 4, L}","category":"page"},{"location":"Continuum Mechanics/","page":"Continuum Mechanics","title":"Continuum Mechanics","text":"DocTestSetup = :(using Tensorial)","category":"page"},{"location":"Continuum Mechanics/#Continuum-Mechanics","page":"Continuum Mechanics","title":"Continuum Mechanics","text":"","category":"section"},{"location":"Continuum Mechanics/","page":"Continuum Mechanics","title":"Continuum Mechanics","text":"Tensor operations for continuum mechanics.","category":"page"},{"location":"Continuum Mechanics/","page":"Continuum Mechanics","title":"Continuum Mechanics","text":"mean(::Tensorial.AbstractSquareTensor{3})","category":"page"},{"location":"Continuum Mechanics/#Statistics.mean-Tuple{Union{AbstractSecondOrderTensor{3, T}, AbstractSymmetricSecondOrderTensor{3, T}, AbstractMat{3, 3, T}} where T}","page":"Continuum Mechanics","title":"Statistics.mean","text":"mean(::AbstractSecondOrderTensor{3})\nmean(::AbstractSymmetricSecondOrderTensor{3})\n\nCompute the mean value of diagonal entries of a square tensor.\n\nExamples\n\njulia> x = rand(Mat{3,3})\n3×3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> mean(x)\n0.3911127467177425\n\n\n\n\n\n","category":"method"},{"location":"Continuum Mechanics/#Deviatoric–volumetric-additive-split","page":"Continuum Mechanics","title":"Deviatoric–volumetric additive split","text":"","category":"section"},{"location":"Continuum Mechanics/","page":"Continuum Mechanics","title":"Continuum Mechanics","text":"vol\ndev","category":"page"},{"location":"Continuum Mechanics/#Tensorial.vol","page":"Continuum Mechanics","title":"Tensorial.vol","text":"vol(::AbstractSecondOrderTensor{3})\nvol(::AbstractSymmetricSecondOrderTensor{3})\n\nCompute the volumetric part of a square tensor. Supported only for tensors in 3D.\n\nExamples\n\njulia> x = rand(Mat{3,3})\n3×3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> vol(x)\n3×3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.391113  0.0       0.0\n 0.0       0.391113  0.0\n 0.0       0.0       0.391113\n\njulia> vol(x) + dev(x) ≈ x\ntrue\n\n\n\n\n\nvol(::AbstractVec{3})\n\nCompute the volumetric part of a vector (assuming principal values of stresses and strains). Supported only for tensors in 3D.\n\nExamples\n\njulia> x = rand(Vec{3})\n3-element Vec{3, Float64}:\n 0.32597672886359486\n 0.5490511363155669\n 0.21858665481883066\n\njulia> vol(x)\n3-element Vec{3, Float64}:\n 0.3645381733326641\n 0.3645381733326641\n 0.3645381733326641\n\njulia> vol(x) + dev(x) ≈ x\ntrue\n\n\n\n\n\nvol(::Type{FourthOrderTensor{3}})\nvol(::Type{SymmetricFourthOrderTensor{3}})\n\nConstruct volumetric fourth order identity tensor. Supported only for tensors in 3D.\n\nExamples\n\njulia> x = rand(Mat{3,3});\n\njulia> I_vol = vol(FourthOrderTensor{3});\n\njulia> I_vol ⊡ x ≈ vol(x)\ntrue\n\njulia> vol(FourthOrderTensor{3}) + dev(FourthOrderTensor{3}) ≈ one(FourthOrderTensor{3})\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Continuum Mechanics/#Tensorial.dev","page":"Continuum Mechanics","title":"Tensorial.dev","text":"dev(::AbstractSecondOrderTensor{3})\ndev(::AbstractSymmetricSecondOrderTensor{3})\n\nCompute the deviatoric part of a square tensor. Supported only for tensors in 3D.\n\nExamples\n\njulia> x = rand(Mat{3,3})\n3×3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> dev(x)\n3×3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n -0.065136   0.894245   0.953125\n  0.549051  -0.0380011  0.795547\n  0.218587   0.394255   0.103137\n\njulia> tr(dev(x))\n5.551115123125783e-17\n\n\n\n\n\ndev(::AbstractVec{3})\n\nCompute the deviatoric part of a vector (assuming principal values of stresses and strains). Supported only for tensors in 3D.\n\nExamples\n\njulia> x = rand(Vec{3})\n3-element Vec{3, Float64}:\n 0.32597672886359486\n 0.5490511363155669\n 0.21858665481883066\n\njulia> dev(x)\n3-element Vec{3, Float64}:\n -0.03856144446906923\n  0.18451296298290282\n -0.14595151851383342\n\njulia> vol(x) + dev(x) ≈ x\ntrue\n\n\n\n\n\ndev(::Type{FourthOrderTensor{3}})\ndev(::Type{SymmetricFourthOrderTensor{3}})\n\nConstruct deviatoric fourth order identity tensor. Supported only for tensors in 3D.\n\nExamples\n\njulia> x = rand(Mat{3,3});\n\njulia> I_dev = dev(FourthOrderTensor{3});\n\njulia> I_dev ⊡ x ≈ dev(x)\ntrue\n\njulia> vol(FourthOrderTensor{3}) + dev(FourthOrderTensor{3}) ≈ one(FourthOrderTensor{3})\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Continuum Mechanics/#Stress-invariants","page":"Continuum Mechanics","title":"Stress invariants","text":"","category":"section"},{"location":"Continuum Mechanics/","page":"Continuum Mechanics","title":"Continuum Mechanics","text":"stress_invariants\ndeviatoric_stress_invariants","category":"page"},{"location":"Continuum Mechanics/#Tensorial.stress_invariants","page":"Continuum Mechanics","title":"Tensorial.stress_invariants","text":"stress_invariants(::AbstractSecondOrderTensor{3})\nstress_invariants(::AbstractSymmetricSecondOrderTensor{3})\n\nReturn a tuple storing stress invariants.\n\nbeginaligned\nI_1(bmsigma) = mathrmtr(bmsigma) \nI_2(bmsigma) = frac12 (mathrmtr(bmsigma)^2 - mathrmtr(bmsigma^2)) \nI_3(bmsigma) = det(bmsigma)\nendaligned\n\nExamples\n\njulia> σ = rand(SymmetricSecondOrderTensor{3})\n3×3 SymmetricSecondOrderTensor{3, Float64, 6}:\n 0.325977  0.549051  0.218587\n 0.549051  0.894245  0.353112\n 0.218587  0.353112  0.394255\n\njulia> I₁, I₂, I₃ = stress_invariants(σ)\n(1.6144775244804341, 0.2986572249840249, -0.0025393241133506677)\n\n\n\n\n\n","category":"function"},{"location":"Continuum Mechanics/#Tensorial.deviatoric_stress_invariants","page":"Continuum Mechanics","title":"Tensorial.deviatoric_stress_invariants","text":"deviatoric_stress_invariants(::AbstractSecondOrderTensor{3})\ndeviatoric_stress_invariants(::AbstractSymmetricSecondOrderTensor{3})\n\nReturn a tuple storing deviatoric stress invariants.\n\nbeginaligned\nJ_1(bmsigma) = mathrmtr(mathrmdev(bmsigma)) = 0 \nJ_2(bmsigma) = frac12 mathrmtr(mathrmdev(bmsigma)^2) \nJ_3(bmsigma) = frac13 mathrmtr(mathrmdev(bmsigma)^3)\nendaligned\n\nExamples\n\njulia> σ = rand(SymmetricSecondOrderTensor{3})\n3×3 SymmetricSecondOrderTensor{3, Float64, 6}:\n 0.325977  0.549051  0.218587\n 0.549051  0.894245  0.353112\n 0.218587  0.353112  0.394255\n\njulia> J₁, J₂, J₃ = deviatoric_stress_invariants(σ)\n(0.0, 0.5701886673667987, 0.14845380911930367)\n\n\n\n\n\n","category":"function"},{"location":"Voigt form/","page":"Voigt Form","title":"Voigt Form","text":"DocTestSetup = :(using Tensorial)","category":"page"},{"location":"Voigt form/#Voigt-Form","page":"Voigt Form","title":"Voigt Form","text":"","category":"section"},{"location":"Voigt form/","page":"Voigt Form","title":"Voigt Form","text":"Order = [:function]\nPages = [\"Voigt form.md\"]","category":"page"},{"location":"Voigt form/","page":"Voigt Form","title":"Voigt Form","text":"Modules = [Tensorial]\nOrder   = [:function]\nPages   = [\"voigt.jl\"]","category":"page"},{"location":"Voigt form/#Tensorial.frommandel-Union{Tuple{T}, Tuple{Type{<:Union{SymmetricFourthOrderTensor, SymmetricSecondOrderTensor}}, AbstractArray{T}}} where T","page":"Voigt Form","title":"Tensorial.frommandel","text":"frommandel(S::Type{<: Union{SymmetricSecondOrderTensor, SymmetricFourthOrderTensor}}, A::AbstractArray{T})\n\nCreate a tensor of type S from Mandel form. This is equivalent to fromvoigt(S, A, offdiagscale = √2).\n\nSee also fromvoigt.\n\n\n\n\n\n","category":"method"},{"location":"Voigt form/#Tensorial.fromvoigt","page":"Voigt Form","title":"Tensorial.fromvoigt","text":"fromvoigt(S::Type{<: Union{SecondOrderTensor, FourthOrderTensor}}, A::AbstractArray{T}; [order])\nfromvoigt(S::Type{<: Union{SymmetricSecondOrderTensor, SymmetricFourthOrderTensor}}, A::AbstractArray{T}; [order, offdiagscale])\n\nConverts an array A stored in Voigt format to a Tensor of type S.\n\nKeyword arguments:\n\noffdiagscale: Determines the scaling factor for the offdiagonal elements.\norder: A vector of cartesian indices (Tuple{Int, Int}) determining the Voigt order. The default order is [(1,1), (2,2), (3,3), (2,3), (1,3), (1,2), (3,2), (3,1), (2,1)] for dim=3.\n\nnote: Note\nSince offdiagscale is the scaling factor for the offdiagonal elements in Voigt form, they are multiplied by 1/offdiagscale in fromvoigt unlike tovoigt. Thus fromvoigt(tovoigt(x, offdiagscale = 2), offdiagscale = 2) returns original x.\n\nSee also tovoigt.\n\nExamples\n\njulia> fromvoigt(Mat{3,3}, 1.0:1.0:9.0)\n3×3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 1.0  6.0  5.0\n 9.0  2.0  4.0\n 8.0  7.0  3.0\n\njulia> fromvoigt(SymmetricSecondOrderTensor{3},\n                 1.0:1.0:6.0,\n                 offdiagscale = 2.0,\n                 order = [(1,1), (2,2), (3,3), (1,2), (1,3), (2,3)])\n3×3 SymmetricSecondOrderTensor{3, Float64, 6}:\n 1.0  2.0  2.5\n 2.0  2.0  3.0\n 2.5  3.0  3.0\n\n\n\n\n\n","category":"function"},{"location":"Voigt form/#Tensorial.tomandel-Tuple{Union{SymmetricFourthOrderTensor, SymmetricSecondOrderTensor}}","page":"Voigt Form","title":"Tensorial.tomandel","text":"tomandel(A::Union{SymmetricSecondOrderTensor, SymmetricFourthOrderTensor})\n\nConvert a tensor to Mandel form which is equivalent to tovoigt(A, offdiagscale = √2).\n\nSee also tovoigt.\n\n\n\n\n\n","category":"method"},{"location":"Voigt form/#Tensorial.tovoigt","page":"Voigt Form","title":"Tensorial.tovoigt","text":"tovoigt(A::Union{SecondOrderTensor, FourthOrderTensor}; [order])\ntovoigt(A::Union{SymmetricSecondOrderTensor, SymmetricFourthOrderTensor}; [order, offdiagonal])\n\nConvert a tensor to Voigt form.\n\nKeyword arguments:\n\noffdiagscale: Determines the scaling factor for the offdiagonal elements.\norder: A vector of cartesian indices (Tuple{Int, Int}) determining the Voigt order. The default order is [(1,1), (2,2), (3,3), (2,3), (1,3), (1,2), (3,2), (3,1), (2,1)] for dim=3.\n\nSee also fromvoigt.\n\nExamples\n\njulia> x = Mat{3,3}(1:9...)\n3×3 Tensor{Tuple{3, 3}, Int64, 2, 9}:\n 1  4  7\n 2  5  8\n 3  6  9\n\njulia> tovoigt(x)\n9-element StaticArrays.SVector{9, Int64} with indices SOneTo(9):\n 1\n 5\n 9\n 8\n 7\n 4\n 6\n 3\n 2\n\njulia> x = SymmetricSecondOrderTensor{3}(1:6...)\n3×3 SymmetricSecondOrderTensor{3, Int64, 6}:\n 1  2  3\n 2  4  5\n 3  5  6\n\njulia> tovoigt(x; offdiagscale = 2,\n                  order = [(1,1), (2,2), (3,3), (1,2), (1,3), (2,3)])\n6-element StaticArrays.SVector{6, Int64} with indices SOneTo(6):\n  1\n  4\n  6\n  4\n  6\n 10\n\n\n\n\n\n","category":"function"},{"location":"Broadcast/","page":"Broadcast","title":"Broadcast","text":"DocTestSetup = :(using Tensorial)","category":"page"},{"location":"Broadcast/#Broadcast","page":"Broadcast","title":"Broadcast","text":"","category":"section"},{"location":"Broadcast/","page":"Broadcast","title":"Broadcast","text":"In Tensorial.jl, subtypes of AbstractTensor basically behave like scalars rather than Array. For example, broadcasting operations on tensors and arrays of tensors will be performed as","category":"page"},{"location":"Broadcast/","page":"Broadcast","title":"Broadcast","text":"julia> x = Vec(1,2,3)\n3-element Vec{3, Int64}:\n 1\n 2\n 3\n\njulia> V = [Vec{3}(i:i+2) for i in 1:4]\n4-element Vector{Vec{3, Int64}}:\n [1, 2, 3]\n [2, 3, 4]\n [3, 4, 5]\n [4, 5, 6]\n\njulia> x .+ V\n4-element Vector{Vec{3, Int64}}:\n [2, 4, 6]\n [3, 5, 7]\n [4, 6, 8]\n [5, 7, 9]\n\njulia> V .= zero(x)\n4-element Vector{Vec{3, Int64}}:\n [0, 0, 0]\n [0, 0, 0]\n [0, 0, 0]\n [0, 0, 0]","category":"page"},{"location":"Broadcast/","page":"Broadcast","title":"Broadcast","text":"On the other hand, broadcasting itself or with scalars and tuples behave the same as built-in Array as","category":"page"},{"location":"Broadcast/","page":"Broadcast","title":"Broadcast","text":"julia> x = Vec(1,2,3)\n3-element Vec{3, Int64}:\n 1\n 2\n 3\n\njulia> sqrt.(x)\n3-element Vec{3, Float64}:\n 1.0\n 1.4142135623730951\n 1.7320508075688772\n\njulia> x .+ 2\n3-element Vec{3, Int64}:\n 3\n 4\n 5\n\njulia> x .+ (2,3,4)\n3-element Vec{3, Int64}:\n 3\n 5\n 7","category":"page"},{"location":"Tensor Inversion/","page":"Tensor Inversion","title":"Tensor Inversion","text":"DocTestSetup = :(using Tensorial)","category":"page"},{"location":"Tensor Inversion/#Tensor-Inversion","page":"Tensor Inversion","title":"Tensor Inversion","text":"","category":"section"},{"location":"Tensor Inversion/","page":"Tensor Inversion","title":"Tensor Inversion","text":"Inversion of 2nd and 4th order tensors are supported.","category":"page"},{"location":"Tensor Inversion/","page":"Tensor Inversion","title":"Tensor Inversion","text":"Order = [:function]\nPages = [\"Tensor Inversion.md\"]","category":"page"},{"location":"Tensor Inversion/","page":"Tensor Inversion","title":"Tensor Inversion","text":"Modules = [Tensorial]\nOrder   = [:function]\nPages   = [\"inv.jl\"]","category":"page"},{"location":"Tensor Inversion/#Base.inv","page":"Tensor Inversion","title":"Base.inv","text":"inv(::AbstractSecondOrderTensor)\ninv(::AbstractSymmetricSecondOrderTensor)\ninv(::AbstractFourthOrderTensor)\ninv(::AbstractSymmetricFourthOrderTensor)\n\nCompute the inverse of a tensor.\n\nExamples\n\njulia> x = rand(SecondOrderTensor{3})\n3×3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> inv(x)\n3×3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n -587.685  -279.668   1583.46\n -411.743  -199.494   1115.12\n  588.35    282.819  -1587.79\n\njulia> x ⋅ inv(x) ≈ one(I)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#Tensorial","page":"Home","title":"Tensorial","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tensorial provides useful tensor operations (e.g., contraction; tensor product, ⊗; inv; etc.) written in the Julia programming language. The library supports arbitrary size of non-symmetric and symmetric tensors, where symmetries should be specified to avoid wasteful duplicate computations. The way to give a size of the tensor is similar to StaticArrays.jl, and symmetries of tensors can be specified by using @Symmetry. For example, symmetric fourth-order tensor (symmetrizing tensor) is represented in this library as Tensor{Tuple{@Symmetry{3,3}, @Symmetry{3,3}}}. Einstein summation macro and automatic differentiation functions are also provided.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add Tensorial","category":"page"},{"location":"#Other-tensor-packages","page":"Home","title":"Other tensor packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Einsum.jl\nTensorOprations.jl\nTensors.jl","category":"page"},{"location":"#Inspiration","page":"Home","title":"Inspiration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"StaticArrays.jl\nTensors.jl","category":"page"}]
}
