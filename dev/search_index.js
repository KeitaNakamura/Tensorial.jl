var documenterSearchIndex = {"docs":
[{"location":"Quaternion/","page":"Quaternion","title":"Quaternion","text":"DocTestSetup = :(using Tensorial)","category":"page"},{"location":"Quaternion/#Quaternion","page":"Quaternion","title":"Quaternion","text":"","category":"section"},{"location":"Quaternion/","page":"Quaternion","title":"Quaternion","text":"Order = [:type, :function]\nPages = [\"Quaternion.md\"]","category":"page"},{"location":"Quaternion/","page":"Quaternion","title":"Quaternion","text":"Modules = [Tensorial]\nOrder   = [:type, :function]\nPages   = [\"quaternion.jl\"]","category":"page"},{"location":"Quaternion/#Tensorial.Quaternion","page":"Quaternion","title":"Tensorial.Quaternion","text":"Quaternion represents q_w + q_x bmi + q_y bmj + q_z bmk. The salar part and vector part can be accessed by q.scalar and q.vector, respectively.\n\nExamples\n\njulia> Quaternion(1,2,3,4)\n1 + 2ð™ž + 3ð™Ÿ + 4ð™ \n\njulia> Quaternion(1)\n1 + 0ð™ž + 0ð™Ÿ + 0ð™ \n\njulia> Quaternion(Vec(1,2,3))\n0 + 1ð™ž + 2ð™Ÿ + 3ð™ \n\nSee also quaternion.\n\nnote: Note\nQuaternion is experimental and could change or disappear in future versions of Tensorial.\n\n\n\n\n\n","category":"type"},{"location":"Quaternion/#Base.exp-Tuple{Quaternion}","page":"Quaternion","title":"Base.exp","text":"exp(::Quaternion)\n\nCompute the exponential of quaternion as\n\nexp(q) = e^q_w left( cos bmv  + fracbmv bmv  sin bmv  right)\n\n\n\n\n\n","category":"method"},{"location":"Quaternion/#Base.log-Tuple{Quaternion}","page":"Quaternion","title":"Base.log","text":"log(::Quaternion)\n\nCompute the logarithm of quaternion as\n\nln(q) = ln q  + fracbmv bmv  arccosfracq_w q \n\n\n\n\n\n","category":"method"},{"location":"Quaternion/#Tensorial.quaternion-Union{Tuple{T}, Tuple{Type{T}, Real, Vec{3}}} where T","page":"Quaternion","title":"Tensorial.quaternion","text":"quaternion(Î¸, n::Vec; normalize = true)\n\nConstruct Quaternion from angle Î¸ and axis n as\n\nq = cosfractheta2 + bmn sinfractheta2\n\nThe constructed quaternion is normalized such as norm(q) â‰ˆ 1 by default.\n\nExamples\n\njulia> q = quaternion(Ï€/4, Vec(0,0,1))\n0.9238795325112867 + 0.0ð™ž + 0.0ð™Ÿ + 0.3826834323650898ð™ \n\njulia> x = rand(Vec{3})\n3-element Vec{3, Float64}:\n 0.32597672886359486\n 0.5490511363155669\n 0.21858665481883066\n\njulia> (q * x / q).vector â‰ˆ rotmatz(Ï€/4) â‹… x\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Quaternion/#Tensorial.rotate-Tuple{Vec, Quaternion}","page":"Quaternion","title":"Tensorial.rotate","text":"rotate(x::Vec, q::Quaternion)\n\nRotate x by quaternion q.\n\nExamples\n\njulia> v = Vec(1.0, 0.0, 0.0)\n3-element Vec{3, Float64}:\n 1.0\n 0.0\n 0.0\n\njulia> rotate(v, quaternion(Ï€/4, Vec(0,0,1)))\n3-element Vec{3, Float64}:\n 0.7071067811865475\n 0.7071067811865476\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"Quaternion/#Tensorial.rotmat-Tuple{Quaternion}","page":"Quaternion","title":"Tensorial.rotmat","text":"rotmat(::Quaternion)\n\nConstruct rotation matrix from quaternion.\n\nExamples\n\njulia> q = quaternion(Ï€/4, Vec(0,0,1))\n0.9238795325112867 + 0.0ð™ž + 0.0ð™Ÿ + 0.3826834323650898ð™ \n\njulia> rotmat(q)\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.707107  -0.707107  0.0\n 0.707107   0.707107  0.0\n 0.0        0.0       1.0\n\n\n\n\n\n","category":"method"},{"location":"Tensor Type/#Tensor-type","page":"Tensor type","title":"Tensor type","text":"","category":"section"},{"location":"Tensor Type/#Type-parameters","page":"Tensor type","title":"Type parameters","text":"","category":"section"},{"location":"Tensor Type/","page":"Tensor type","title":"Tensor type","text":"All tensors in Tensorial.jl are represented by the type Tensor{S, T, N, L}, where each type parameter represents the following:","category":"page"},{"location":"Tensor Type/","page":"Tensor type","title":"Tensor type","text":"S: The size of Tensors which is specified by using Tuple (e.g., 3x2 tensor becomes Tensor{Tuple{3,2}}).\nT: The type of element which must be T <: Real.\nN: The number of dimensions (the order of tensor).\nL: The number of independent components.","category":"page"},{"location":"Tensor Type/","page":"Tensor type","title":"Tensor type","text":"Basically, the type parameters N and L do not need to be specified for constructing tensors because it can be inferred from the size of tensor S.","category":"page"},{"location":"Tensor Type/#Symmetry","page":"Tensor type","title":"Symmetry","text":"","category":"section"},{"location":"Tensor Type/","page":"Tensor type","title":"Tensor type","text":"Specifying the symmetry of a tensor can improve performance, as Tensorial.jl provides optimized computations for symmetric tensors. Symmetries can be applied using Symmetry in the type parameter S (e.g., Symmetry{Tuple{3,3}}). The @Symmetry macro simplifies this process by allowing you to omit Tuple, as in @Symmetry{2,2}. Below are some examples of how to specify symmetries:","category":"page"},{"location":"Tensor Type/","page":"Tensor type","title":"Tensor type","text":"A_(ij) with 3x3: Tensor{Tuple{@Symmetry{3,3}}}\nA_(ij)k with 3x3x2: Tensor{Tuple{@Symmetry{3,3}, 2}}\nA_(ijk) with 3x3x3: Tensor{Tuple{@Symmetry{3,3,3}}}\nA_(ij)(kl) with 3x3x3x3: Tensor{Tuple{@Symmetry{3,3}, @Symmetry{3,3}}}","category":"page"},{"location":"Tensor Type/","page":"Tensor type","title":"Tensor type","text":"where the bracket () in indices denotes the symmetry.","category":"page"},{"location":"Cheat Sheet/#Cheat-Sheet","page":"Cheat Sheet","title":"Cheat Sheet","text":"","category":"section"},{"location":"Cheat Sheet/#Constructors","page":"Cheat Sheet","title":"Constructors","text":"","category":"section"},{"location":"Cheat Sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"# tensor aliases\nrand(Vec{3})                        # vector\nrand(Mat{2,3})                      # matrix\nrand(SecondOrderTensor{3})          # 3x3 second-order tensor (this is the same as the Mat{3,3})\nrand(SymmetricSecondOrderTensor{3}) # 3x3 symmetric second-order tensor (3x3 symmetric matrix)\nrand(FourthOrderTensor{3})          # 3x3x3x3 fourth-order tensor\nrand(SymmetricFourthOrderTensor{3}) # 3x3x3x3 symmetric fourth-order tensor\n\n# identity tensors\none(SecondOrderTensor{3,3})        # second-order identity tensor\none(SymmetricSecondOrderTensor{3}) # symmetric second-order identity tensor\none(FourthOrderTensor{3})          # fourth-order identity tensor\none(SymmetricFourthOrderTensor{3}) # symmetric fourth-order identity tensor (symmetrizing tensor)\n\n# zero tensors\nzero(Mat{2,3}) == zeros(2,3)\nzero(SymmetricSecondOrderTensor{3}) == zeros(3,3)\n\n# random tensors\nrand(Mat{2,3})\nrandn(Mat{2,3})\n\n# from arrays\nMat{2,2}([1 2; 3 4]) == [1 2; 3 4]\nSymmetricSecondOrderTensor{2}([1 2; 3 4]) == [1 3; 3 4] # lower triangular part is used\n\n# from functions\nMat{2,2}((i,j) -> i == j ? 1 : 0) == one(Mat{2,2})\nSymmetricSecondOrderTensor{2}((i,j) -> i == j ? 1 : 0) == one(SymmetricSecondOrderTensor{2})\n\n# macros (same interface as StaticArrays.jl)\n@Vec [1,2,3]\n@Vec rand(4)\n@Mat [1 2\n      3 4]\n@Mat rand(4,4)\n@Tensor rand(2,2,2)\n\n# statically sized getindex by `@Tensor`\nx = @Mat [1 2\n          3 4\n          5 6]\n@Tensor(x[2:3, :])   === @Mat [3 4\n                               5 6]\n@Tensor(x[[1,3], :]) === @Mat [1 2\n                               5 6]","category":"page"},{"location":"Cheat Sheet/#Tensor-Operations","page":"Cheat Sheet","title":"Tensor Operations","text":"","category":"section"},{"location":"Cheat Sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"# 2nd-order vs. 2nd-order\nx = rand(Mat{2,2})\ny = rand(SymmetricSecondOrderTensor{2})\nx âŠ— y isa Tensor{Tuple{2,2,@Symmetry{2,2}}} # tensor product\nx â‹… y isa Tensor{Tuple{2,2}}                # single contraction (x_ij * y_jk)\nx âŠ¡ y isa Real                              # double contraction (x_ij * y_ij)\n\n# 3rd-order vs. 1st-order\nA = rand(Tensor{Tuple{@Symmetry{2,2},2}})\nv = rand(Vec{2})\nA âŠ— v isa Tensor{Tuple{@Symmetry{2,2},2,2}} # A_ijk * v_l\nA â‹… v isa Tensor{Tuple{@Symmetry{2,2}}}     # A_ijk * v_k\nA âŠ¡ v # error\n\n# 4th-order vs. 2nd-order\nII = one(SymmetricFourthOrderTensor{2}) # equal to one(Tensor{Tuple{@Symmetry{2,2}, @Symmetry{2,2}}})\nA = rand(Mat{2,2})\nS = rand(SymmetricSecondOrderTensor{2})\nII âŠ¡ A == (A + A') / 2 == symmetric(A) # symmetrizing A, resulting in Tensor{Tuple{@Symmetry{2,2}}}\nII âŠ¡ S == S\n\n# contraction\nx = rand(Tensor{Tuple{2,2,2}})\ny = rand(Tensor{Tuple{2,@Symmetry{2,2}}})\ncontraction(x, y, Val(1)) isa Tensor{Tuple{2,2, @Symmetry{2,2}}}     # single contraction (== â‹…)\ncontraction(x, y, Val(2)) isa Tensor{Tuple{2,2}}                     # double contraction (== âŠ¡)\ncontraction(x, y, Val(3)) isa Real                                   # triple contraction (x_ijk * y_ijk)\ncontraction(x, y, Val(0)) isa Tensor{Tuple{2,2,2,2, @Symmetry{2,2}}} # tensor product (== âŠ—)\n\n# norm/tr/mean/vol/dev\nx = rand(SecondOrderTensor{3}) # equal to rand(Tensor{Tuple{3,3}})\nv = rand(Vec{3})\nnorm(v)\ntr(x)\nmean(x) == tr(x) / 3 # useful for computing mean stress\nvol(x) + dev(x) == x # decomposition into volumetric part and deviatoric part\n\n# det/inv for 2nd-order tensor\nA = rand(SecondOrderTensor{3})          # equal to one(Tensor{Tuple{3,3}})\nS = rand(SymmetricSecondOrderTensor{3}) # equal to one(Tensor{Tuple{@Symmetry{3,3}}})\ndet(A); det(S)\ninv(A) â‹… A â‰ˆ one(A)\ninv(S) â‹… S â‰ˆ one(S)\n\n# inv for 4th-order tensor\nAA = rand(FourthOrderTensor{3})          # equal to one(Tensor{Tuple{3,3,3,3}})\nSS = rand(SymmetricFourthOrderTensor{3}) # equal to one(Tensor{Tuple{@Symmetry{3,3}, @Symmetry{3,3}}})\ninv(AA) âŠ¡ AA â‰ˆ one(AA)\ninv(SS) âŠ¡ SS â‰ˆ one(SS)\n\n# Einstein summation convention\nA = rand(Mat{3,3})\nB = rand(Mat{3,3})\n(@einsum (i,j) -> A[i,k] * B[k,j]) == A â‹… B\n(@einsum A[i,j] * B[i,j]) == A âŠ¡ B","category":"page"},{"location":"Cheat Sheet/#Automatic-differentiation","page":"Cheat Sheet","title":"Automatic differentiation","text":"","category":"section"},{"location":"Cheat Sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"# Real -> Real\ngradient(x -> 2x^2 + x + 3, 3) == (x = 3; 4x + 1)\ngradient(x -> 2.0, 3) == 0.0\n\n# Real -> Tensor\ngradient(x -> Mat{2,2}((i,j) -> i*x^2), 3) == (x = 3; Mat{2,2}((i,j) -> 2i*x))\ngradient(x -> one(Mat{2,2}), 3) == zero(Mat{2,2})\n\n# Tensor -> Real\ngradient(tr, rand(Mat{3,3})) == one(Mat{3,3})\n\n# Tensor -> Tensor\nA = rand(Mat{3,3})\nD  = gradient(dev, A)            # deviatoric projection tensor\nDs = gradient(dev, symmetric(A)) # symmetric deviatoric projection tensor\nA âŠ¡ D  â‰ˆ dev(A)\nA âŠ¡ Ds â‰ˆ symmetric(dev(A))\ngradient(identity, A) == one(FourthOrderTensor{3})                     # 4th-order identity tensor\ngradient(identity, symmetric(A)) == one(SymmetricFourthOrderTensor{3}) # symmetric 4th-order identity tensor","category":"page"},{"location":"Cheat Sheet/#Aliases","page":"Cheat Sheet","title":"Aliases","text":"","category":"section"},{"location":"Cheat Sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"const Vec{dim, T} = Tensor{Tuple{dim}, T, 1, dim}\nconst Mat{m, n, T, L} = Tensor{Tuple{m, n}, T, 2, L}\nconst SecondOrderTensor{dim, T, L} = Tensor{NTuple{2, dim}, T, 2, L}\nconst FourthOrderTensor{dim, T, L} = Tensor{NTuple{4, dim}, T, 4, L}\nconst SymmetricSecondOrderTensor{dim, T, L} = Tensor{Tuple{@Symmetry{dim, dim}}, T, 2, L}\nconst SymmetricFourthOrderTensor{dim, T, L} = Tensor{NTuple{2, @Symmetry{dim, dim}}, T, 4, L}","category":"page"},{"location":"Voigt form/","page":"Voigt Form","title":"Voigt Form","text":"DocTestSetup = :(using Tensorial)","category":"page"},{"location":"Voigt form/#Voigt-Form","page":"Voigt Form","title":"Voigt Form","text":"","category":"section"},{"location":"Voigt form/","page":"Voigt Form","title":"Voigt Form","text":"Order = [:function]\nPages = [\"Voigt form.md\"]","category":"page"},{"location":"Voigt form/","page":"Voigt Form","title":"Voigt Form","text":"Modules = [Tensorial]\nOrder   = [:function]\nPages   = [\"voigt.jl\"]","category":"page"},{"location":"Voigt form/#Tensorial.frommandel-Union{Tuple{T}, Tuple{Type{<:Union{SymmetricSecondOrderTensor, SymmetricFourthOrderTensor}}, AbstractArray{T}}} where T","page":"Voigt Form","title":"Tensorial.frommandel","text":"frommandel(S::Type{<: Union{SymmetricSecondOrderTensor, SymmetricFourthOrderTensor}}, A::AbstractArray{T})\n\nCreate a tensor of type S from Mandel form. This is equivalent to fromvoigt(S, A, offdiagscale = âˆš2).\n\nSee also fromvoigt.\n\n\n\n\n\n","category":"method"},{"location":"Voigt form/#Tensorial.fromvoigt","page":"Voigt Form","title":"Tensorial.fromvoigt","text":"fromvoigt(S::Type{<: Union{SecondOrderTensor, FourthOrderTensor}}, A::AbstractArray{T}; [order])\nfromvoigt(S::Type{<: Union{SymmetricSecondOrderTensor, SymmetricFourthOrderTensor}}, A::AbstractArray{T}; [order, offdiagscale])\n\nConverts an array A stored in Voigt format to a Tensor of type S.\n\nKeyword arguments:\n\noffdiagscale: Determines the scaling factor for the offdiagonal elements.\norder: A vector of cartesian indices (Tuple{Int, Int}) determining the Voigt order. The default order is [(1,1), (2,2), (3,3), (2,3), (1,3), (1,2), (3,2), (3,1), (2,1)] for dim=3.\n\nnote: Note\nSince offdiagscale is the scaling factor for the offdiagonal elements in Voigt form, they are multiplied by 1/offdiagscale in fromvoigt unlike tovoigt. Thus fromvoigt(tovoigt(x, offdiagscale = 2), offdiagscale = 2) returns original x.\n\nSee also tovoigt.\n\nExamples\n\njulia> fromvoigt(Mat{3,3}, 1.0:1.0:9.0)\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 1.0  6.0  5.0\n 9.0  2.0  4.0\n 8.0  7.0  3.0\n\njulia> fromvoigt(SymmetricSecondOrderTensor{3},\n                 1.0:1.0:6.0,\n                 offdiagscale = 2.0,\n                 order = [(1,1), (2,2), (3,3), (1,2), (1,3), (2,3)])\n3Ã—3 SymmetricSecondOrderTensor{3, Float64, 6}:\n 1.0  2.0  2.5\n 2.0  2.0  3.0\n 2.5  3.0  3.0\n\n\n\n\n\n","category":"function"},{"location":"Voigt form/#Tensorial.tomandel-Tuple{Union{SymmetricSecondOrderTensor, SymmetricFourthOrderTensor}}","page":"Voigt Form","title":"Tensorial.tomandel","text":"tomandel(A::Union{SymmetricSecondOrderTensor, SymmetricFourthOrderTensor})\n\nConvert a tensor to Mandel form which is equivalent to tovoigt(A, offdiagscale = âˆš2).\n\nSee also tovoigt.\n\n\n\n\n\n","category":"method"},{"location":"Voigt form/#Tensorial.tovoigt","page":"Voigt Form","title":"Tensorial.tovoigt","text":"tovoigt(A::Union{SecondOrderTensor, FourthOrderTensor}; [order])\ntovoigt(A::Union{SymmetricSecondOrderTensor, SymmetricFourthOrderTensor}; [order, offdiagonal])\n\nConvert a tensor to Voigt form.\n\nKeyword arguments:\n\noffdiagscale: Determines the scaling factor for the offdiagonal elements.\norder: A vector of cartesian indices (Tuple{Int, Int}) determining the Voigt order. The default order is [(1,1), (2,2), (3,3), (2,3), (1,3), (1,2), (3,2), (3,1), (2,1)] for dim=3.\n\nSee also fromvoigt.\n\nExamples\n\njulia> x = Mat{3,3}(1:9...)\n3Ã—3 Tensor{Tuple{3, 3}, Int64, 2, 9}:\n 1  4  7\n 2  5  8\n 3  6  9\n\njulia> tovoigt(x)\n9-element StaticArraysCore.SVector{9, Int64} with indices SOneTo(9):\n 1\n 5\n 9\n 8\n 7\n 4\n 6\n 3\n 2\n\njulia> x = SymmetricSecondOrderTensor{3}(1:6...)\n3Ã—3 SymmetricSecondOrderTensor{3, Int64, 6}:\n 1  2  3\n 2  4  5\n 3  5  6\n\njulia> tovoigt(x; offdiagscale = 2,\n                  order = [(1,1), (2,2), (3,3), (1,2), (1,3), (2,3)])\n6-element StaticArraysCore.SVector{6, Int64} with indices SOneTo(6):\n  1\n  4\n  6\n  4\n  6\n 10\n\n\n\n\n\n","category":"function"},{"location":"Operations/","page":"Operations","title":"Operations","text":"DocTestSetup = :(using Tensorial)","category":"page"},{"location":"Operations/#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"Operations/#Basic-operations","page":"Operations","title":"Basic operations","text":"","category":"section"},{"location":"Operations/","page":"Operations","title":"Operations","text":"cross\nnorm\nnormalize\ntr\ninv","category":"page"},{"location":"Operations/#LinearAlgebra.cross","page":"Operations","title":"LinearAlgebra.cross","text":"cross(x::Vec, y::Vec)\nx Ã— y\n\nCompute the cross product between two vectors. The infix operation x Ã— y (where Ã— can be typed by \\times<tab>) is a synonym for cross(x, y).\n\nExamples\n\njulia> x = rand(Vec{3})\n3-element Vec{3, Float64}:\n 0.32597672886359486\n 0.5490511363155669\n 0.21858665481883066\n\njulia> y = rand(Vec{3})\n3-element Vec{3, Float64}:\n 0.8942454282009883\n 0.35311164439921205\n 0.39425536741585077\n\njulia> x Ã— y\n3-element Vec{3, Float64}:\n  0.13928086435138393\n  0.0669520417303531\n -0.37588028973385323\n\n\n\n\n\n","category":"function"},{"location":"Operations/#LinearAlgebra.norm","page":"Operations","title":"LinearAlgebra.norm","text":"norm(::AbstractTensor)\n\nCompute norm of a tensor.\n\nExamples\n\njulia> x = rand(Mat{3, 3})\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> norm(x)\n1.8223398556552728\n\n\n\n\n\n","category":"function"},{"location":"Operations/#LinearAlgebra.normalize","page":"Operations","title":"LinearAlgebra.normalize","text":"normalize(x)\n\nCompute x / norm(x).\n\n\n\n\n\n","category":"function"},{"location":"Operations/#LinearAlgebra.tr","page":"Operations","title":"LinearAlgebra.tr","text":"tr(A)\n\nCompute the trace of a square tensor A.\n\nExamples\n\njulia> A = rand(Mat{3,3})\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> tr(A)\n1.1733382401532275\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Base.inv","page":"Operations","title":"Base.inv","text":"inv(A)\n\nCompute the inverse of a tensor A. A can be of the following types: SecondOrderTensor, SymmetricSecondOrderTensor, FourthOrderTensor, or SymmetricFourthOrderTensor.\n\nExamples\n\njulia> x = rand(SecondOrderTensor{3})\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> inv(x)\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n -587.685  -279.668   1583.46\n -411.743  -199.494   1115.12\n  588.35    282.819  -1587.79\n\njulia> x â‹… inv(x) â‰ˆ one(I)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Tensor-operations","page":"Operations","title":"Tensor operations","text":"","category":"section"},{"location":"Operations/","page":"Operations","title":"Operations","text":"contract\notimes\n^\n@einsum","category":"page"},{"location":"Operations/#Tensorial.contract","page":"Operations","title":"Tensorial.contract","text":"contract(x, y, ::Val{N})\n\nConduct contraction of N inner indices. For example, N=2 contraction for third-order tensors A_ij = B_ikl C_klj can be computed as follows:\n\nExamples\n\njulia> B = rand(Tensor{Tuple{3,3,3}});\n\njulia> C = rand(Tensor{Tuple{3,3,3}});\n\njulia> A = contract(B, C, Val(2))\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 3.70978  2.47156  3.91807\n 2.90966  2.30881  3.25965\n 1.78391  1.38714  2.2079\n\nThe following infix operators are also available for specific contractions:\n\nx â‹… y (where â‹… can be typed by \\cdot<tab> ): contract(x, y, Val(1))\nx âŠ¡ y (where âŠ¡ can be typed by \\boxdot<tab> ): contract(x, y, Val(2))\nx âŠ— y (where âŠ— can be typed by \\otimes<tab> ): contract(x, y, Val(0))\n\n\n\n\n\ncontract(x, y, Val(xdims), Val(ydims))\n\nPerform contraction over the given dimensions.\n\nExamples\n\njulia> A = rand(Mat{3,3})\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> B = rand(Mat{3,3})\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.748415  0.00744801  0.682533\n 0.578232  0.199377    0.956741\n 0.727935  0.439243    0.647855\n\njulia> contract(A, B, Val(1), Val(2)) â‰ˆ @einsum A[k,i] * B[j,k]\ntrue\n\njulia> contract(A, B, Val((1,2)), Val((2,1))) â‰ˆ @einsum A[i,j] * B[j,i]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Tensorial.otimes","page":"Operations","title":"Tensorial.otimes","text":"otimes(x::AbstractTensor, y::AbstractTensor)\nx âŠ— y\n\nCompute tensor product such as A_ij = x_i y_j. x âŠ— y (where âŠ— can be typed by \\otimes<tab>) is a synonym for otimes(x, y).\n\nExamples\n\njulia> x = rand(Vec{3})\n3-element Vec{3, Float64}:\n 0.32597672886359486\n 0.5490511363155669\n 0.21858665481883066\n\njulia> y = rand(Vec{3})\n3-element Vec{3, Float64}:\n 0.8942454282009883\n 0.35311164439921205\n 0.39425536741585077\n\njulia> A = x âŠ— y\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.291503  0.115106   0.128518\n 0.490986  0.193876   0.216466\n 0.19547   0.0771855  0.086179\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Base.:^","page":"Operations","title":"Base.:^","text":"x^âŠ—(n)\n\nn-fold tensor product of a tensor x.\n\nExamples\n\njulia> x = rand(Vec{2})\n2-element Vec{2, Float64}:\n 0.32597672886359486\n 0.5490511363155669\n\njulia> x^âŠ—(3)\n2Ã—2Ã—2 Tensor{Tuple{Symmetry{Tuple{2, 2, 2}}}, Float64, 3, 4}:\n[:, :, 1] =\n 0.0346386  0.0583426\n 0.0583426  0.098268\n\n[:, :, 2] =\n 0.0583426  0.098268\n 0.098268   0.165515\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Tensorial.@einsum","page":"Operations","title":"Tensorial.@einsum","text":"@einsum [TensorType] (i,j...) -> expr\n@einsum [TensorType] expr\n\nPerforms tensor computations using the Einstein summation convention. The arguments of the anonymous function are treated as free indices. If no arguments are provided, they are inferred based on the order in which the indices appear from left to right. Since @einsum cannot fully infer tensor symmetries, it is possible to annotate the returned tensor type (though this is not checked for correctness). This can help eliminate the computation of the symmetric part, improving performance.\n\nExamples\n\njulia> A = rand(Mat{3,3});\n\njulia> B = rand(Mat{3,3});\n\njulia> (@einsum (i,j) -> A[j,k] * B[k,i]) â‰ˆ (A â‹… B)'\ntrue\n\njulia> (@einsum A[i,k] * B[k,j]) â‰ˆ A â‹… B\ntrue\n\njulia> (@einsum A[i,j] * A[i,j]) â‰ˆ A âŠ¡ A\ntrue\n\njulia> (@einsum SymmetricSecondOrderTensor{3} A[k,i] * A[k,j]) â‰ˆ A' â‹… A\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"Operations/#Symmetry","page":"Operations","title":"Symmetry","text":"","category":"section"},{"location":"Operations/","page":"Operations","title":"Operations","text":"symmetric\nskew\nminorsymmetric","category":"page"},{"location":"Operations/#Tensorial.symmetric","page":"Operations","title":"Tensorial.symmetric","text":"symmetric(::AbstractSecondOrderTensor)\nsymmetric(::AbstractSecondOrderTensor, uplo)\n\nCompute the symmetric part of a second order tensor.\n\nExamples\n\njulia> x = rand(Mat{3,3})\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> symmetric(x)\n3Ã—3 SymmetricSecondOrderTensor{3, Float64, 6}:\n 0.325977  0.721648  0.585856\n 0.721648  0.353112  0.594901\n 0.585856  0.594901  0.49425\n\njulia> symmetric(x, :U)\n3Ã—3 SymmetricSecondOrderTensor{3, Float64, 6}:\n 0.325977  0.894245  0.953125\n 0.894245  0.353112  0.795547\n 0.953125  0.795547  0.49425\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Tensorial.skew","page":"Operations","title":"Tensorial.skew","text":"skew(A)\n\nCompute skew-symmetric (anti-symmetric) part of a second order tensor.\n\nExamples\n\njulia> x = rand(Mat{3,3})\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> symmetric(x) + skew(x) â‰ˆ x\ntrue\n\n\n\n\n\nskew(Ï‰::Vec{3})\n\nConstruct a skew-symmetric (anti-symmetric) tensor W from a vector Ï‰ as\n\nbmomega = beginBmatrix\n    omega_1 \n    omega_2 \n    omega_3\nendBmatrix quad\nbmW = beginbmatrix\n     0          -omega_3   omega_2 \n     omega_3  0           -omega_1 \n    -omega_2   omega_1   0\nendbmatrix\n\nExamples\n\njulia> skew(Vec(1,2,3))\n3Ã—3 Tensor{Tuple{3, 3}, Int64, 2, 9}:\n  0  -3   2\n  3   0  -1\n -2   1   0\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Tensorial.minorsymmetric","page":"Operations","title":"Tensorial.minorsymmetric","text":"minorsymmetric(::AbstractFourthOrderTensor) -> SymmetricFourthOrderTensor\n\nCompute the minor symmetric part of a fourth order tensor.\n\nExamples\n\njulia> x = rand(Tensor{Tuple{3,3,3,3}});\n\njulia> minorsymmetric(x) â‰ˆ @einsum (i,j,k,l) -> (x[i,j,k,l] + x[j,i,k,l] + x[i,j,l,k] + x[j,i,l,k]) / 4\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Rotation","page":"Operations","title":"Rotation","text":"","category":"section"},{"location":"Operations/","page":"Operations","title":"Operations","text":"rotmatx\nrotmaty\nrotmatz\nrotmat\nrotate","category":"page"},{"location":"Operations/#Tensorial.rotmatx","page":"Operations","title":"Tensorial.rotmatx","text":"rotmatx(Î¸::Number)\n\nConstruct rotation matrix around x axis.\n\nbmR_x = beginbmatrix\n1  0  0 \n0  costheta  -sintheta \n0  sintheta   costheta\nendbmatrix\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Tensorial.rotmaty","page":"Operations","title":"Tensorial.rotmaty","text":"rotmaty(Î¸::Number)\n\nConstruct rotation matrix around y axis.\n\nbmR_y = beginbmatrix\ncostheta  0  sintheta \n0  1  0 \n-sintheta  0  costheta\nendbmatrix\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Tensorial.rotmatz","page":"Operations","title":"Tensorial.rotmatz","text":"rotmatz(Î¸::Number)\n\nConstruct rotation matrix around z axis.\n\nbmR_z = beginbmatrix\ncostheta  -sintheta  0 \nsintheta   costheta  0 \n0  0  1\nendbmatrix\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Tensorial.rotmat","page":"Operations","title":"Tensorial.rotmat","text":"rotmat(Î¸::Number)\n\nConstruct 2D rotation matrix.\n\nbmR = beginbmatrix\ncostheta  -sintheta \nsintheta   costheta\nendbmatrix\n\nExamples\n\njulia> rotmat(deg2rad(30))\n2Ã—2 Tensor{Tuple{2, 2}, Float64, 2, 4}:\n 0.866025  -0.5\n 0.5        0.866025\n\n\n\n\n\nrotmat(Î¸::Vec{3}; sequence::Symbol)\n\nConvert Euler angles to rotation matrix. Use 3 characters belonging to the set (X, Y, Z) for intrinsic rotations, or (x, y, z) for extrinsic rotations.\n\nExamples\n\njulia> Î±, Î², Î³ = map(deg2rad, rand(3));\n\njulia> rotmat(Vec(Î±,Î²,Î³), sequence = :XYZ) â‰ˆ rotmatx(Î±) â‹… rotmaty(Î²) â‹… rotmatz(Î³)\ntrue\n\njulia> rotmat(Vec(Î±,Î²,Î³), sequence = :xyz) â‰ˆ rotmatz(Î³) â‹… rotmaty(Î²) â‹… rotmatx(Î±)\ntrue\n\njulia> rotmat(Vec(Î±,Î²,Î³), sequence = :XYZ) â‰ˆ rotmat(Vec(Î³,Î²,Î±), sequence = :zyx)\ntrue\n\n\n\n\n\nrotmat(a => b)\n\nConstruct rotation matrix rotating vector a to b. The norms of two vectors must be the same.\n\nExamples\n\njulia> a = normalize(rand(Vec{3}))\n3-element Vec{3, Float64}:\n 0.4829957515506539\n 0.8135223859352438\n 0.3238771859304809\n\njulia> b = normalize(rand(Vec{3}))\n3-element Vec{3, Float64}:\n 0.8605677447967596\n 0.3398133016944055\n 0.3794075336718636\n\njulia> R = rotmat(a => b)\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n -0.00540771   0.853773   0.520617\n  0.853773    -0.267108   0.446905\n  0.520617     0.446905  -0.727485\n\njulia> R â‹… a â‰ˆ b\ntrue\n\n\n\n\n\nrotmat(Î¸, n::Vec)\n\nConstruct rotation matrix from angle Î¸ and axis n.\n\nExamples\n\njulia> x = Vec(1.0, 0.0, 0.0)\n3-element Vec{3, Float64}:\n 1.0\n 0.0\n 0.0\n\njulia> n = Vec(0.0, 0.0, 1.0)\n3-element Vec{3, Float64}:\n 0.0\n 0.0\n 1.0\n\njulia> rotmat(Ï€/2, n) â‹… x\n3-element Vec{3, Float64}:\n 6.123233995736766e-17\n 1.0\n 0.0\n\n\n\n\n\nrotmat(::Quaternion)\n\nConstruct rotation matrix from quaternion.\n\nExamples\n\njulia> q = quaternion(Ï€/4, Vec(0,0,1))\n0.9238795325112867 + 0.0ð™ž + 0.0ð™Ÿ + 0.3826834323650898ð™ \n\njulia> rotmat(q)\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.707107  -0.707107  0.0\n 0.707107   0.707107  0.0\n 0.0        0.0       1.0\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Tensorial.rotate","page":"Operations","title":"Tensorial.rotate","text":"rotate(x, R::SecondOrderTensor)\n\nRotate x using the rotation matrix R. This function preserves the symmetry of the matrix.\n\nExamples\n\njulia> R = rotmatz(Ï€/4)\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.707107  -0.707107  0.0\n 0.707107   0.707107  0.0\n 0.0        0.0       1.0\n\njulia> rotate(Vec(1,0,0), R)\n3-element Vec{3, Float64}:\n 0.7071067811865476\n 0.7071067811865475\n 0.0\n\njulia> A = rand(SymmetricSecondOrderTensor{3})\n3Ã—3 SymmetricSecondOrderTensor{3, Float64, 6}:\n 0.325977  0.549051  0.218587\n 0.549051  0.894245  0.353112\n 0.218587  0.353112  0.394255\n\njulia> rotate(A, R) â‰ˆ R â‹… A â‹… R'\ntrue\n\n\n\n\n\nrotate(x::Vec, q::Quaternion)\n\nRotate x by quaternion q.\n\nExamples\n\njulia> v = Vec(1.0, 0.0, 0.0)\n3-element Vec{3, Float64}:\n 1.0\n 0.0\n 0.0\n\njulia> rotate(v, quaternion(Ï€/4, Vec(0,0,1)))\n3-element Vec{3, Float64}:\n 0.7071067811865475\n 0.7071067811865476\n 0.0\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Continuum-mechanics","page":"Operations","title":"Continuum mechanics","text":"","category":"section"},{"location":"Operations/","page":"Operations","title":"Operations","text":"vol(::Tensorial.AbstractSquareTensor{3})\ndev(::Tensorial.AbstractSquareTensor{3})\nmean(::Tensorial.AbstractSquareTensor{3})\nvonmises\nstress_invariants\ndeviatoric_stress_invariants","category":"page"},{"location":"Operations/#Tensorial.vol-Tuple{Union{AbstractSecondOrderTensor{3, T}, AbstractSymmetricSecondOrderTensor{3, T}, AbstractMat{3, 3, T}} where T}","page":"Operations","title":"Tensorial.vol","text":"vol(A)\n\nCompute the volumetric part of a square tensor A. This is only available in 3D.\n\nExamples\n\njulia> x = rand(Mat{3,3})\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> vol(x)\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.391113  0.0       0.0\n 0.0       0.391113  0.0\n 0.0       0.0       0.391113\n\njulia> vol(x) + dev(x) â‰ˆ x\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Operations/#Tensorial.dev-Tuple{Union{AbstractSecondOrderTensor{3, T}, AbstractSymmetricSecondOrderTensor{3, T}, AbstractMat{3, 3, T}} where T}","page":"Operations","title":"Tensorial.dev","text":"dev(::AbstractSecondOrderTensor{3})\ndev(::AbstractSymmetricSecondOrderTensor{3})\n\nCompute the deviatoric part of a square tensor. This is only available in 3D.\n\nExamples\n\njulia> x = rand(Mat{3,3})\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> dev(x)\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n -0.065136   0.894245   0.953125\n  0.549051  -0.0380011  0.795547\n  0.218587   0.394255   0.103137\n\njulia> tr(dev(x))\n5.551115123125783e-17\n\n\n\n\n\n","category":"method"},{"location":"Operations/#Statistics.mean-Tuple{Union{AbstractSecondOrderTensor{3, T}, AbstractSymmetricSecondOrderTensor{3, T}, AbstractMat{3, 3, T}} where T}","page":"Operations","title":"Statistics.mean","text":"mean(A)\n\nCompute the mean value of diagonal entries of a square tensor A.\n\nExamples\n\njulia> x = rand(Mat{3,3})\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> mean(x)\n0.3911127467177425\n\n\n\n\n\n","category":"method"},{"location":"Operations/#Tensorial.vonmises","page":"Operations","title":"Tensorial.vonmises","text":"vonmises(::AbstractSymmetricSecondOrderTensor{3})\n\nCompute the von Mises stress.\n\nq = sqrtfrac32 mathrmdev(bmsigma)  mathrmdev(bmsigma) = sqrt3J_2\n\nExamples\n\njulia> Ïƒ = rand(SymmetricSecondOrderTensor{3})\n3Ã—3 SymmetricSecondOrderTensor{3, Float64, 6}:\n 0.325977  0.549051  0.218587\n 0.549051  0.894245  0.353112\n 0.218587  0.353112  0.394255\n\njulia> vonmises(Ïƒ)\n1.3078860814690232\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Tensorial.stress_invariants","page":"Operations","title":"Tensorial.stress_invariants","text":"stress_invariants(::AbstractSecondOrderTensor{3})\nstress_invariants(::AbstractSymmetricSecondOrderTensor{3})\nstress_invariants(::Vec{3})\n\nReturn a tuple storing stress invariants.\n\nbeginaligned\nI_1(bmsigma) = mathrmtr(bmsigma) \nI_2(bmsigma) = frac12 (mathrmtr(bmsigma)^2 - mathrmtr(bmsigma^2)) \nI_3(bmsigma) = det(bmsigma)\nendaligned\n\nExamples\n\njulia> Ïƒ = rand(SymmetricSecondOrderTensor{3})\n3Ã—3 SymmetricSecondOrderTensor{3, Float64, 6}:\n 0.325977  0.549051  0.218587\n 0.549051  0.894245  0.353112\n 0.218587  0.353112  0.394255\n\njulia> Iâ‚, Iâ‚‚, Iâ‚ƒ = stress_invariants(Ïƒ)\n(1.6144775244804341, 0.2986572249840249, -0.0025393241133506677)\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Tensorial.deviatoric_stress_invariants","page":"Operations","title":"Tensorial.deviatoric_stress_invariants","text":"deviatoric_stress_invariants(::AbstractSecondOrderTensor{3})\ndeviatoric_stress_invariants(::AbstractSymmetricSecondOrderTensor{3})\ndeviatoric_stress_invariants(::Vec{3})\n\nReturn a tuple storing deviatoric stress invariants.\n\nbeginaligned\nJ_1(bmsigma) = mathrmtr(mathrmdev(bmsigma)) = 0 \nJ_2(bmsigma) = frac12 mathrmtr(mathrmdev(bmsigma)^2) \nJ_3(bmsigma) = frac13 mathrmtr(mathrmdev(bmsigma)^3)\nendaligned\n\nExamples\n\njulia> Ïƒ = rand(SymmetricSecondOrderTensor{3})\n3Ã—3 SymmetricSecondOrderTensor{3, Float64, 6}:\n 0.325977  0.549051  0.218587\n 0.549051  0.894245  0.353112\n 0.218587  0.353112  0.394255\n\njulia> Jâ‚, Jâ‚‚, Jâ‚ƒ = deviatoric_stress_invariants(Ïƒ)\n(0.0, 0.5701886673667987, 0.14845380911930367)\n\n\n\n\n\n","category":"function"},{"location":"Benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"Benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"a = rand(Vec{3})\nA = rand(SecondOrderTensor{3})\nS = rand(SymmetricSecondOrderTensor{3})\nB = rand(Tensor{Tuple{3,3,3}})\nAA = rand(FourthOrderTensor{3})\nSS = rand(SymmetricFourthOrderTensor{3})","category":"page"},{"location":"Benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Operation Tensor Array speed-up\nSingle contraction   \na â‹… a 3.095 ns 9.266 ns Ã—3.0\nA â‹… a 3.406 ns 53.128 ns Ã—15.6\nS â‹… a 3.406 ns 53.121 ns Ã—15.6\nDouble contraction   \nA âŠ¡ A 3.456 ns 10.531 ns Ã—3.0\nS âŠ¡ S 3.406 ns 10.530 ns Ã—3.1\nB âŠ¡ A 5.419 ns 109.037 ns Ã—20.1\nAA âŠ¡ A 7.732 ns 129.262 ns Ã—16.7\nSS âŠ¡ S 4.207 ns 130.805 ns Ã—31.1\nTensor product   \na âŠ— a 3.406 ns 31.063 ns Ã—9.1\nCross product   \na Ã— a 3.406 ns 31.063 ns Ã—9.1\nDeterminant   \ndet(A) 2.855 ns 152.409 ns Ã—53.4\ndet(S) 2.855 ns 164.318 ns Ã—57.6\nInverse   \ninv(A) 5.981 ns 430.597 ns Ã—72.0\ninv(S) 4.889 ns 460.653 ns Ã—94.2\ninv(AA) 945.444 ns 1.536 Î¼s Ã—1.6\ninv(SS) 339.206 ns 1.542 Î¼s Ã—4.5","category":"page"},{"location":"Benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The benchmarks are generated by runbenchmarks.jl on the following system:","category":"page"},{"location":"Benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"julia> versioninfo()\nJulia Version 1.11.1\nCommit 8f5b7ca12ad (2024-10-16 10:53 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 4 Ã— AMD EPYC 7763 64-Core Processor\n  WORD_SIZE: 64\n  LLVM: libLLVM-16.0.6 (ORCJIT, znver3)\nThreads: 1 default, 0 interactive, 1 GC (on 4 virtual cores)\n","category":"page"},{"location":"Constructors/","page":"Constructors","title":"Constructors","text":"DocTestSetup = :(using Tensorial)","category":"page"},{"location":"Constructors/#Constructors","page":"Constructors","title":"Constructors","text":"","category":"section"},{"location":"Constructors/#From-an-AbstractArray","page":"Constructors","title":"From an AbstractArray","text":"","category":"section"},{"location":"Constructors/","page":"Constructors","title":"Constructors","text":"using Tensorial","category":"page"},{"location":"Constructors/","page":"Constructors","title":"Constructors","text":"Vec{2}([1 2])\nVec{2,Float64}([1 2])\nMat{2,2}([1 2; 3 4])\nMat{2,2,Float64}([1 2; 3 4])\nSymmetricSecondOrderTensor{2}([1 2; 3 4]) # InexactError\nSymmetricSecondOrderTensor{2}([1 2; 2 4])","category":"page"},{"location":"Constructors/#From-a-function","page":"Constructors","title":"From a function","text":"","category":"section"},{"location":"Constructors/","page":"Constructors","title":"Constructors","text":"using Tensorial","category":"page"},{"location":"Constructors/","page":"Constructors","title":"Constructors","text":"Î´ = one(Mat{2,2})\nI = SymmetricFourthOrderTensor{2}((i,j,k,l) -> (Î´[i,k]*Î´[j,l] + Î´[i,l]*Î´[j,k])/2)\nI == one(SymmetricFourthOrderTensor{2})","category":"page"},{"location":"Constructors/#Identity-tensors","page":"Constructors","title":"Identity tensors","text":"","category":"section"},{"location":"Constructors/","page":"Constructors","title":"Constructors","text":"one","category":"page"},{"location":"Constructors/#Base.one","page":"Constructors","title":"Base.one","text":"one(TensorType)\n\nConstruct an identity tensor. The supported TensorTypes are as follows:\n\nSecondOrderTensor{dim}\nSymmetricSecondOrderTensor{dim}\nFourthOrderTensor{dim}\nSymmetricFourthOrderTensor{dim}\n\njulia> Î´ = one(Mat{3,3})\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> one(SymmetricFourthOrderTensor{3}) â‰ˆ @einsum (i,j,k,l) -> (Î´[i,k]*Î´[j,l] + Î´[i,l]*Î´[j,k]) / 2\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Constructors/#Zero-tensors","page":"Constructors","title":"Zero tensors","text":"","category":"section"},{"location":"Constructors/","page":"Constructors","title":"Constructors","text":"zero","category":"page"},{"location":"Constructors/#Base.zero","page":"Constructors","title":"Base.zero","text":"zero(TensorType)\n\nConstruct a zero tensor.\n\njulia> zero(Vec{2})\n2-element Vec{2, Float64}:\n 0.0\n 0.0\n\njulia> zero(Mat{2,3})\n2Ã—3 Mat{2, 3, Float64, 6}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"Constructors/#Macros","page":"Constructors","title":"Macros","text":"","category":"section"},{"location":"Constructors/","page":"Constructors","title":"Constructors","text":"@Vec\n@Mat\n@Tensor","category":"page"},{"location":"Constructors/#Tensorial.@Vec","page":"Constructors","title":"Tensorial.@Vec","text":"@Vec [a, b, c, d]\n@Vec [i for i in 1:2]\n@Vec ones(2)\n\nA convenient macro to construct Vec.\n\n\n\n\n\n","category":"macro"},{"location":"Constructors/#Tensorial.@Mat","page":"Constructors","title":"Tensorial.@Mat","text":"@Mat [a b c d]\n@Mat [[a, b];[c, d]]\n@Mat [i+j for i in 1:2, j in 1:2]\n@Mat ones(2, 2)\n\nA convenient macro to construct Mat.\n\n\n\n\n\n","category":"macro"},{"location":"Constructors/#Tensorial.@Tensor","page":"Constructors","title":"Tensorial.@Tensor","text":"@Tensor [a b; c d]\n@Tensor [[a, b];[c, d]]\n@Tensor [i+j for i in 1:2, j in 1:2]\n@Tensor ones(2, 2, 2)\n\nA convenient macro to construct Tensor with arbitrary dimension.\n\n\n\n\n\n","category":"macro"},{"location":"Constructors/#Other-special-tensors","page":"Constructors","title":"Other special tensors","text":"","category":"section"},{"location":"Constructors/#Levi-Civita","page":"Constructors","title":"Levi-Civita","text":"","category":"section"},{"location":"Constructors/","page":"Constructors","title":"Constructors","text":"levicivita","category":"page"},{"location":"Constructors/#Tensorial.levicivita","page":"Constructors","title":"Tensorial.levicivita","text":"levicivita(::Val{N} = Val(3))\n\nReturn N dimensional Levi-Civita tensor.\n\nExamples\n\njulia> Ïµ = levicivita()\n3Ã—3Ã—3 Tensor{Tuple{3, 3, 3}, Int64, 3, 27}:\n[:, :, 1] =\n 0   0  0\n 0   0  1\n 0  -1  0\n\n[:, :, 2] =\n 0  0  -1\n 0  0   0\n 1  0   0\n\n[:, :, 3] =\n  0  1  0\n -1  0  0\n  0  0  0\n\n\n\n\n\n","category":"function"},{"location":"Broadcast/#Broadcast","page":"Broadcast","title":"Broadcast","text":"","category":"section"},{"location":"Broadcast/","page":"Broadcast","title":"Broadcast","text":"In Tensorial.jl, Tensor behaves like a scalar rather than an Array when performing broadcasting, as follows:","category":"page"},{"location":"Broadcast/","page":"Broadcast","title":"Broadcast","text":"using Tensorial","category":"page"},{"location":"Broadcast/","page":"Broadcast","title":"Broadcast","text":"x = Vec(1,2,3)\nV = [Vec{3}(i:i+2) for i in 1:4]\nx .+ V\nV .= zero(x)","category":"page"},{"location":"Broadcast/","page":"Broadcast","title":"Broadcast","text":"Conversely, broadcasting a Tensor itself or with scalars and tuples behaves the same as built-in Array, as shown below:","category":"page"},{"location":"Broadcast/","page":"Broadcast","title":"Broadcast","text":"using Tensorial","category":"page"},{"location":"Broadcast/","page":"Broadcast","title":"Broadcast","text":"x = Vec(1,2,3)\nsqrt.(x)\nx .+ 2\nx .+ (2,3,4)","category":"page"},{"location":"#Tensorial.jl","page":"Home","title":"Tensorial.jl","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tensorial.jl provides statically sized Tensor which is compatible with the AbstractArray, similar to the SArray in StaticArrays.jl. In addition to the basic operations for AbstractArray, the package also offers a tensorial interface and several convenient features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Contraction, tensor product (âŠ—), and a flexible @einsum macro for Einstein summation convention\nA @Symmetry macro to define the tensor symmetries, which eliminates unnecessary calculations\nAutomatic differentiation through gradient and hessian functions","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add Tensorial","category":"page"},{"location":"#Other-tensor-packages","page":"Home","title":"Other tensor packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Einsum.jl\nTensorOprations.jl\nTensors.jl","category":"page"},{"location":"#Inspiration","page":"Home","title":"Inspiration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"StaticArrays.jl\nTensors.jl","category":"page"},{"location":"Automatic differentiation/","page":"Automatic differentiation","title":"Automatic differentiation","text":"DocTestSetup = :(using Tensorial)","category":"page"},{"location":"Automatic differentiation/#Automatic-differentiation","page":"Automatic differentiation","title":"Automatic differentiation","text":"","category":"section"},{"location":"Automatic differentiation/","page":"Automatic differentiation","title":"Automatic differentiation","text":"Order = [:type, :function]\nPages = [\"Automatic differentiation.md\"]","category":"page"},{"location":"Automatic differentiation/","page":"Automatic differentiation","title":"Automatic differentiation","text":"Modules = [Tensorial]\nOrder   = [:type, :function]\nPages   = [\"ad.jl\"]","category":"page"},{"location":"Automatic differentiation/#Tensorial.gradient-Tuple{Any, Union{Number, AbstractTensor}}","page":"Automatic differentiation","title":"Tensorial.gradient","text":"gradient(f, x)\ngradient(f, x, :all)\n\nCompute the gradient of f with respect to x by the automatic differentiation. If pseudo keyword :all is given, the value of f(x) is also returned.\n\nExamples\n\njulia> x = rand(Mat{3,3})\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> gradient(tr, x)\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> âˆ‡f, f = gradient(tr, x, :all)\n([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0], 1.1733382401532275)\n\n\n\n\n\n","category":"method"},{"location":"Automatic differentiation/#Tensorial.hessian-Tuple{Any, Union{Number, AbstractTensor}}","page":"Automatic differentiation","title":"Tensorial.hessian","text":"hessian(f, x)\nhessian(f, x, :all)\n\nCompute the hessian of f with respect to x by the automatic differentiation. If pseudo keyword :all is given, the value of f(x) is also returned.\n\nExamples\n\njulia> x = rand(Vec{3})\n3-element Vec{3, Float64}:\n 0.32597672886359486\n 0.5490511363155669\n 0.21858665481883066\n\njulia> hessian(norm, x)\n3Ã—3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n  1.13603   -0.582196  -0.231782\n -0.582196   0.501079  -0.390397\n -0.231782  -0.390397   1.32626\n\njulia> âˆ‡âˆ‡f, âˆ‡f, f = hessian(norm, x, :all)\n([1.1360324375454411 -0.5821964220304534 -0.23178236037013888; -0.5821964220304533 0.5010791569244991 -0.39039709608344814; -0.23178236037013886 -0.39039709608344814 1.3262640626479867], [0.4829957515506539, 0.8135223859352438, 0.3238771859304809], 0.6749059962060727)\n\n\n\n\n\n","category":"method"}]
}
