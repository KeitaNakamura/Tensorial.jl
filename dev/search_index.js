var documenterSearchIndex = {"docs":
[{"location":"Getting started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"Getting started/#Quick-start","page":"Getting started","title":"Quick start","text":"","category":"section"},{"location":"Getting started/","page":"Getting started","title":"Getting started","text":"using Tensorial","category":"page"},{"location":"Getting started/","page":"Getting started","title":"Getting started","text":"using Tensorial\nx = Vec{3}(rand(3)); # constructor similar to SArray.jl\nA = @Mat rand(3,3); # @Vec, @Mat and @Tensor, analogous to @SVector, @SMatrix and @SArray\nA ‚ãÖ x ‚âà A * x # single contraction (‚ãÖ)\nA ‚ä° A ‚âà tr(A'A) # double contraction (‚ä°)\nx ‚äó x ‚âà x * x' # tensor product (‚äó)\n(@einsum x[i] * A[j,i] * x[j]) ‚âà x ‚ãÖ A' ‚ãÖ x # Einstein summation (@einsum)\nS = rand(Tensor{Tuple{@Symmetry{3,3}}}); # specify symmetry S‚Çç·µ¢‚±º‚Çé\nSS = rand(Tensor{Tuple{@Symmetry{3,3}, @Symmetry{3,3}}}); # SS‚Çç·µ¢‚±º‚Çé‚Çç‚Çñ‚Çó‚Çé\ninv(SS) ‚ä° S ‚âà @einsum inv(SS)[i,j,k,l] * S[k,l] # it just works\nŒ¥ = one(Mat{3,3}) # identity tensor\ngradient(identity, S) ‚âà one(SS) # ‚àÇS·µ¢‚±º/‚àÇS‚Çñ‚Çó = (Œ¥·µ¢‚ÇñŒ¥‚±º‚Çó + Œ¥·µ¢‚ÇóŒ¥‚±º‚Çñ) / 2","category":"page"},{"location":"Getting started/#Defining-tensors","page":"Getting started","title":"Defining tensors","text":"","category":"section"},{"location":"Getting started/#1.-Tensor","page":"Getting started","title":"1. Tensor","text":"","category":"section"},{"location":"Getting started/","page":"Getting started","title":"Getting started","text":"All tensors in Tensorial.jl are represented by the type Tensor{S, T, N, L}, where each type parameter represents the following:","category":"page"},{"location":"Getting started/","page":"Getting started","title":"Getting started","text":"S: The size of Tensors which is specified by using Tuple (e.g., 3√ó2 tensor becomes Tensor{Tuple{3,2}}).\nT: The type of element which must be T <: Real.\nN: The number of dimensions (the order of tensor).\nL: The number of independent components.","category":"page"},{"location":"Getting started/","page":"Getting started","title":"Getting started","text":"The type parameters N and T do not need to be specified when Constructing tensors, as they can be inferred from the size of tensor S. However, when defining Tensors in a struct, it is necessary to declare all type parameters to avoid type instability, as follows:","category":"page"},{"location":"Getting started/","page":"Getting started","title":"Getting started","text":"using Tensorial","category":"page"},{"location":"Getting started/","page":"Getting started","title":"Getting started","text":"struct MyBadType{T} # all bad\n    A::Tensor{Tuple{3,3}, Float64}\n    B::Tensor{Tuple{3,3}, T}\n    C::Tensor{Tuple{@Symmetry{3,3}}, T, 2}\nend\n\nstruct MyGoodType{T, dim, L, TT <: Tensor} # all good\n    A::Tensor{Tuple{3,3}, Float64, 2, 9}\n    B::Tensor{Tuple{3,3}, T, 2, 9}\n    C::Tensor{Tuple{@Symmetry{dim,dim}}, T, 2, L}\n    D::TT\nend","category":"page"},{"location":"Getting started/","page":"Getting started","title":"Getting started","text":"tips: Tips\nThe type parameters N and L can be checked using the @Tensor macro as follows:@Tensor{Tuple{@Symmetry{3,3,3}}}","category":"page"},{"location":"Getting started/#2.-Symmetry","page":"Getting started","title":"2. Symmetry","text":"","category":"section"},{"location":"Getting started/","page":"Getting started","title":"Getting started","text":"Specifying the symmetry of a tensor can improve performance, as Tensorial.jl eliminates duplicate computations. Symmetries can be applied using Symmetry in the type parameter S (e.g., Symmetry{Tuple{3,3}}). The @Symmetry macro simplifies this process by allowing you to omit Tuple, as in @Symmetry{3,3}. Below are some examples of how to specify symmetries:","category":"page"},{"location":"Getting started/","page":"Getting started","title":"Getting started","text":"A_(ij) with 3x3: Tensor{Tuple{@Symmetry{3,3}}}\nA_(ij)k with 3x3x3: Tensor{Tuple{@Symmetry{3,3}, 3}}\nA_(ijk) with 3x3x3: Tensor{Tuple{@Symmetry{3,3,3}}}\nA_(ij)(kl) with 3x3x3x3: Tensor{Tuple{@Symmetry{3,3}, @Symmetry{3,3}}}","category":"page"},{"location":"Getting started/","page":"Getting started","title":"Getting started","text":"where the bracket () in the indices denotes the symmetry.","category":"page"},{"location":"Getting started/#Aliases","page":"Getting started","title":"Aliases","text":"","category":"section"},{"location":"Getting started/","page":"Getting started","title":"Getting started","text":"const Vec{dim, T} = Tensor{Tuple{dim}, T, 1, dim}\nconst Mat{m, n, T, L} = Tensor{Tuple{m, n}, T, 2, L}\nconst SecondOrderTensor{dim, T, L} = Tensor{NTuple{2, dim}, T, 2, L}\nconst FourthOrderTensor{dim, T, L} = Tensor{NTuple{4, dim}, T, 4, L}\nconst SymmetricSecondOrderTensor{dim, T, L} = Tensor{Tuple{@Symmetry{dim, dim}}, T, 2, L}\nconst SymmetricFourthOrderTensor{dim, T, L} = Tensor{NTuple{2, @Symmetry{dim, dim}}, T, 4, L}","category":"page"},{"location":"Quaternion/","page":"Quaternion","title":"Quaternion","text":"DocTestSetup = :(using Tensorial)","category":"page"},{"location":"Quaternion/#Quaternion","page":"Quaternion","title":"Quaternion","text":"","category":"section"},{"location":"Quaternion/","page":"Quaternion","title":"Quaternion","text":"Order = [:type, :function]\nPages = [\"Quaternion.md\"]","category":"page"},{"location":"Quaternion/","page":"Quaternion","title":"Quaternion","text":"Modules = [Tensorial]\nOrder   = [:type, :function]\nPages   = [\"quaternion.jl\"]","category":"page"},{"location":"Quaternion/#Tensorial.Quaternion","page":"Quaternion","title":"Tensorial.Quaternion","text":"Quaternion represents q_w + q_x bmi + q_y bmj + q_z bmk. The salar part and vector part can be accessed by q.scalar and q.vector, respectively.\n\nExamples\n\njulia> Quaternion(1,2,3,4)\n1 + 2ùôû + 3ùôü + 4ùô†\n\njulia> Quaternion(1)\n1 + 0ùôû + 0ùôü + 0ùô†\n\njulia> Quaternion(Vec(1,2,3))\n0 + 1ùôû + 2ùôü + 3ùô†\n\nSee also quaternion.\n\nnote: Note\nQuaternion is experimental and could change or disappear in future versions of Tensorial.\n\n\n\n\n\n","category":"type"},{"location":"Quaternion/#Base.exp-Tuple{Quaternion}","page":"Quaternion","title":"Base.exp","text":"exp(::Quaternion)\n\nCompute the exponential of quaternion as\n\nexp(q) = e^q_w left( cos bmv  + fracbmv bmv  sin bmv  right)\n\n\n\n\n\n","category":"method"},{"location":"Quaternion/#Base.log-Tuple{Quaternion}","page":"Quaternion","title":"Base.log","text":"log(::Quaternion)\n\nCompute the logarithm of quaternion as\n\nln(q) = ln q  + fracbmv bmv  arccosfracq_w q \n\n\n\n\n\n","category":"method"},{"location":"Quaternion/#Tensorial.quaternion-Union{Tuple{T}, Tuple{Type{T}, Real, Vec{3}}} where T","page":"Quaternion","title":"Tensorial.quaternion","text":"quaternion(Œ∏, n::Vec; normalize = true)\n\nConstruct Quaternion from angle Œ∏ and axis n as\n\nq = cosfractheta2 + bmn sinfractheta2\n\nThe constructed quaternion is normalized such as norm(q) ‚âà 1 by default.\n\nExamples\n\njulia> q = quaternion(œÄ/4, Vec(0,0,1))\n0.9238795325112867 + 0.0ùôû + 0.0ùôü + 0.3826834323650898ùô†\n\njulia> x = rand(Vec{3})\n3-element Vec{3, Float64}:\n 0.32597672886359486\n 0.5490511363155669\n 0.21858665481883066\n\njulia> (q * x / q).vector ‚âà rotmatz(œÄ/4) ‚ãÖ x\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Quaternion/#Tensorial.rotate-Tuple{Vec, Quaternion}","page":"Quaternion","title":"Tensorial.rotate","text":"rotate(x::Vec, q::Quaternion)\n\nRotate x by quaternion q.\n\nExamples\n\njulia> v = Vec(1.0, 0.0, 0.0)\n3-element Vec{3, Float64}:\n 1.0\n 0.0\n 0.0\n\njulia> rotate(v, quaternion(œÄ/4, Vec(0,0,1)))\n3-element Vec{3, Float64}:\n 0.7071067811865475\n 0.7071067811865476\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"Quaternion/#Tensorial.rotmat-Tuple{Quaternion}","page":"Quaternion","title":"Tensorial.rotmat","text":"rotmat(::Quaternion)\n\nConstruct rotation matrix from quaternion.\n\nExamples\n\njulia> q = quaternion(œÄ/4, Vec(0,0,1))\n0.9238795325112867 + 0.0ùôû + 0.0ùôü + 0.3826834323650898ùô†\n\njulia> rotmat(q)\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.707107  -0.707107  0.0\n 0.707107   0.707107  0.0\n 0.0        0.0       1.0\n\n\n\n\n\n","category":"method"},{"location":"Voigt form/","page":"Voigt Form","title":"Voigt Form","text":"DocTestSetup = :(using Tensorial)","category":"page"},{"location":"Voigt form/#Voigt-Form","page":"Voigt Form","title":"Voigt Form","text":"","category":"section"},{"location":"Voigt form/","page":"Voigt Form","title":"Voigt Form","text":"Order = [:function]\nPages = [\"Voigt form.md\"]","category":"page"},{"location":"Voigt form/","page":"Voigt Form","title":"Voigt Form","text":"Modules = [Tensorial]\nOrder   = [:function]\nPages   = [\"voigt.jl\"]","category":"page"},{"location":"Voigt form/#Tensorial.frommandel-Union{Tuple{T}, Tuple{Type{<:Union{SymmetricSecondOrderTensor, SymmetricFourthOrderTensor}}, AbstractArray{T}}} where T","page":"Voigt Form","title":"Tensorial.frommandel","text":"frommandel(S::Type{<: Union{SymmetricSecondOrderTensor, SymmetricFourthOrderTensor}}, A::AbstractArray{T})\n\nCreate a tensor of type S from Mandel form. This is equivalent to fromvoigt(S, A, offdiagscale = ‚àö2).\n\nSee also fromvoigt.\n\n\n\n\n\n","category":"method"},{"location":"Voigt form/#Tensorial.fromvoigt","page":"Voigt Form","title":"Tensorial.fromvoigt","text":"fromvoigt(S::Type{<: Union{SecondOrderTensor, FourthOrderTensor}}, A::AbstractArray{T}; [order])\nfromvoigt(S::Type{<: Union{SymmetricSecondOrderTensor, SymmetricFourthOrderTensor}}, A::AbstractArray{T}; [order, offdiagscale])\n\nConverts an array A stored in Voigt format to a Tensor of type S.\n\nKeyword arguments:\n\noffdiagscale: Determines the scaling factor for the offdiagonal elements.\norder: A vector of cartesian indices (Tuple{Int, Int}) determining the Voigt order. The default order is [(1,1), (2,2), (3,3), (2,3), (1,3), (1,2), (3,2), (3,1), (2,1)] for dim=3.\n\nnote: Note\nSince offdiagscale is the scaling factor for the offdiagonal elements in Voigt form, they are multiplied by 1/offdiagscale in fromvoigt unlike tovoigt. Thus fromvoigt(tovoigt(x, offdiagscale = 2), offdiagscale = 2) returns original x.\n\nSee also tovoigt.\n\nExamples\n\njulia> fromvoigt(Mat{3,3}, 1.0:1.0:9.0)\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 1.0  6.0  5.0\n 9.0  2.0  4.0\n 8.0  7.0  3.0\n\njulia> fromvoigt(SymmetricSecondOrderTensor{3},\n                 1.0:1.0:6.0,\n                 offdiagscale = 2.0,\n                 order = [(1,1), (2,2), (3,3), (1,2), (1,3), (2,3)])\n3√ó3 SymmetricSecondOrderTensor{3, Float64, 6}:\n 1.0  2.0  2.5\n 2.0  2.0  3.0\n 2.5  3.0  3.0\n\n\n\n\n\n","category":"function"},{"location":"Voigt form/#Tensorial.tomandel-Tuple{Union{SymmetricSecondOrderTensor, SymmetricFourthOrderTensor}}","page":"Voigt Form","title":"Tensorial.tomandel","text":"tomandel(A::Union{SymmetricSecondOrderTensor, SymmetricFourthOrderTensor})\n\nConvert a tensor to Mandel form which is equivalent to tovoigt(A, offdiagscale = ‚àö2).\n\nSee also tovoigt.\n\n\n\n\n\n","category":"method"},{"location":"Voigt form/#Tensorial.tovoigt","page":"Voigt Form","title":"Tensorial.tovoigt","text":"tovoigt(A::Union{SecondOrderTensor, FourthOrderTensor}; [order])\ntovoigt(A::Union{SymmetricSecondOrderTensor, SymmetricFourthOrderTensor}; [order, offdiagonal])\n\nConvert a tensor to Voigt form.\n\nKeyword arguments:\n\noffdiagscale: Determines the scaling factor for the offdiagonal elements.\norder: A vector of cartesian indices (Tuple{Int, Int}) determining the Voigt order. The default order is [(1,1), (2,2), (3,3), (2,3), (1,3), (1,2), (3,2), (3,1), (2,1)] for dim=3.\n\nSee also fromvoigt.\n\nExamples\n\njulia> x = Mat{3,3}(1:9...)\n3√ó3 Tensor{Tuple{3, 3}, Int64, 2, 9}:\n 1  4  7\n 2  5  8\n 3  6  9\n\njulia> tovoigt(x)\n9-element StaticArraysCore.SVector{9, Int64} with indices SOneTo(9):\n 1\n 5\n 9\n 8\n 7\n 4\n 6\n 3\n 2\n\njulia> x = SymmetricSecondOrderTensor{3}(1:6...)\n3√ó3 SymmetricSecondOrderTensor{3, Int64, 6}:\n 1  2  3\n 2  4  5\n 3  5  6\n\njulia> tovoigt(x; offdiagscale = 2,\n                  order = [(1,1), (2,2), (3,3), (1,2), (1,3), (2,3)])\n6-element StaticArraysCore.SVector{6, Int64} with indices SOneTo(6):\n  1\n  4\n  6\n  4\n  6\n 10\n\n\n\n\n\n","category":"function"},{"location":"Operations/","page":"Operations","title":"Operations","text":"DocTestSetup = :(using Tensorial)","category":"page"},{"location":"Operations/#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"Operations/#Basic-operations","page":"Operations","title":"Basic operations","text":"","category":"section"},{"location":"Operations/","page":"Operations","title":"Operations","text":"cross\nnorm\nnormalize\ntr\ninv","category":"page"},{"location":"Operations/#LinearAlgebra.cross","page":"Operations","title":"LinearAlgebra.cross","text":"cross(x::Vec, y::Vec)\nx √ó y\n\nCompute the cross product between two vectors. The infix operation x √ó y (where √ó can be typed by \\times<tab>) is a synonym for cross(x, y).\n\nExamples\n\njulia> x = rand(Vec{3})\n3-element Vec{3, Float64}:\n 0.32597672886359486\n 0.5490511363155669\n 0.21858665481883066\n\njulia> y = rand(Vec{3})\n3-element Vec{3, Float64}:\n 0.8942454282009883\n 0.35311164439921205\n 0.39425536741585077\n\njulia> x √ó y\n3-element Vec{3, Float64}:\n  0.13928086435138393\n  0.0669520417303531\n -0.37588028973385323\n\n\n\n\n\n","category":"function"},{"location":"Operations/#LinearAlgebra.norm","page":"Operations","title":"LinearAlgebra.norm","text":"norm(::AbstractTensor)\n\nCompute norm of a tensor.\n\nExamples\n\njulia> x = rand(Mat{3, 3})\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> norm(x)\n1.8223398556552728\n\n\n\n\n\n","category":"function"},{"location":"Operations/#LinearAlgebra.normalize","page":"Operations","title":"LinearAlgebra.normalize","text":"normalize(x)\n\nCompute x / norm(x).\n\n\n\n\n\n","category":"function"},{"location":"Operations/#LinearAlgebra.tr","page":"Operations","title":"LinearAlgebra.tr","text":"tr(A)\n\nCompute the trace of a square tensor A.\n\nExamples\n\njulia> A = rand(Mat{3,3})\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> tr(A)\n1.1733382401532275\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Base.inv","page":"Operations","title":"Base.inv","text":"inv(A)\n\nCompute the inverse of a tensor A. A can be of the following types: SecondOrderTensor, SymmetricSecondOrderTensor, FourthOrderTensor, or SymmetricFourthOrderTensor.\n\nExamples\n\njulia> x = rand(SecondOrderTensor{3})\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> inv(x)\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n -587.685  -279.668   1583.46\n -411.743  -199.494   1115.12\n  588.35    282.819  -1587.79\n\njulia> x ‚ãÖ inv(x) ‚âà one(I)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Tensor-operations","page":"Operations","title":"Tensor operations","text":"","category":"section"},{"location":"Operations/","page":"Operations","title":"Operations","text":"contract\notimes\n^\n@einsum","category":"page"},{"location":"Operations/#Tensorial.contract","page":"Operations","title":"Tensorial.contract","text":"contract(x, y, ::Val{N})\n\nConduct contraction of N inner indices. For example, N=2 contraction for third-order tensors A_ij = B_ikl C_klj can be computed as follows:\n\nExamples\n\njulia> B = rand(Tensor{Tuple{3,3,3}});\n\njulia> C = rand(Tensor{Tuple{3,3,3}});\n\njulia> A = contract(B, C, Val(2))\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 3.70978  2.47156  3.91807\n 2.90966  2.30881  3.25965\n 1.78391  1.38714  2.2079\n\nThe following infix operators are also available for specific contractions:\n\nx ‚ãÖ y (where ‚ãÖ can be typed by \\cdot<tab> ): contract(x, y, Val(1))\nx ‚ä° y (where ‚ä° can be typed by \\boxdot<tab> ): contract(x, y, Val(2))\nx ‚äó y (where ‚äó can be typed by \\otimes<tab> ): contract(x, y, Val(0))\n\n\n\n\n\ncontract(x, y, Val(xdims), Val(ydims))\n\nPerform contraction over the given dimensions.\n\nExamples\n\njulia> A = rand(Mat{3,3})\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> B = rand(Mat{3,3})\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.748415  0.00744801  0.682533\n 0.578232  0.199377    0.956741\n 0.727935  0.439243    0.647855\n\njulia> contract(A, B, Val(1), Val(2)) ‚âà @einsum A[k,i] * B[j,k]\ntrue\n\njulia> contract(A, B, Val((1,2)), Val((2,1))) ‚âà @einsum A[i,j] * B[j,i]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Tensorial.otimes","page":"Operations","title":"Tensorial.otimes","text":"otimes(x::AbstractTensor, y::AbstractTensor)\nx ‚äó y\n\nCompute tensor product such as A_ij = x_i y_j. x ‚äó y (where ‚äó can be typed by \\otimes<tab>) is a synonym for otimes(x, y).\n\nExamples\n\njulia> x = rand(Vec{3})\n3-element Vec{3, Float64}:\n 0.32597672886359486\n 0.5490511363155669\n 0.21858665481883066\n\njulia> y = rand(Vec{3})\n3-element Vec{3, Float64}:\n 0.8942454282009883\n 0.35311164439921205\n 0.39425536741585077\n\njulia> A = x ‚äó y\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.291503  0.115106   0.128518\n 0.490986  0.193876   0.216466\n 0.19547   0.0771855  0.086179\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Base.:^","page":"Operations","title":"Base.:^","text":"x^‚äó(n)\n\nn-fold tensor product of a tensor x.\n\nExamples\n\njulia> x = rand(Vec{2})\n2-element Vec{2, Float64}:\n 0.32597672886359486\n 0.5490511363155669\n\njulia> x^‚äó(3)\n2√ó2√ó2 Tensor{Tuple{Symmetry{Tuple{2, 2, 2}}}, Float64, 3, 4}:\n[:, :, 1] =\n 0.0346386  0.0583426\n 0.0583426  0.098268\n\n[:, :, 2] =\n 0.0583426  0.098268\n 0.098268   0.165515\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Tensorial.@einsum","page":"Operations","title":"Tensorial.@einsum","text":"@einsum [TensorType] (i,j...) -> expr\n@einsum [TensorType] expr\n\nPerforms tensor computations using the Einstein summation convention. The arguments of the anonymous function are treated as free indices. If no arguments are provided, they are inferred based on the order in which the indices appear from left to right. Since @einsum cannot fully infer tensor symmetries, it is possible to annotate the returned tensor type (though this is not checked for correctness). This can help eliminate the computation of the symmetric part, improving performance.\n\nExamples\n\njulia> A = rand(Mat{3,3});\n\njulia> B = rand(Mat{3,3});\n\njulia> (@einsum (i,j) -> A[j,k] * B[k,i]) ‚âà (A ‚ãÖ B)'\ntrue\n\njulia> (@einsum A[i,k] * B[k,j]) ‚âà A ‚ãÖ B\ntrue\n\njulia> (@einsum A[i,j] * A[i,j]) ‚âà A ‚ä° A\ntrue\n\njulia> (@einsum SymmetricSecondOrderTensor{3} A[k,i] * A[k,j]) ‚âà A' ‚ãÖ A\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"Operations/#Symmetry","page":"Operations","title":"Symmetry","text":"","category":"section"},{"location":"Operations/","page":"Operations","title":"Operations","text":"symmetric\nskew\nminorsymmetric","category":"page"},{"location":"Operations/#Tensorial.symmetric","page":"Operations","title":"Tensorial.symmetric","text":"symmetric(::AbstractSecondOrderTensor)\nsymmetric(::AbstractSecondOrderTensor, uplo)\n\nCompute the symmetric part of a second order tensor.\n\nExamples\n\njulia> x = rand(Mat{3,3})\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> symmetric(x)\n3√ó3 SymmetricSecondOrderTensor{3, Float64, 6}:\n 0.325977  0.721648  0.585856\n 0.721648  0.353112  0.594901\n 0.585856  0.594901  0.49425\n\njulia> symmetric(x, :U)\n3√ó3 SymmetricSecondOrderTensor{3, Float64, 6}:\n 0.325977  0.894245  0.953125\n 0.894245  0.353112  0.795547\n 0.953125  0.795547  0.49425\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Tensorial.skew","page":"Operations","title":"Tensorial.skew","text":"skew(A)\n\nCompute skew-symmetric (anti-symmetric) part of a second order tensor.\n\nExamples\n\njulia> x = rand(Mat{3,3})\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> symmetric(x) + skew(x) ‚âà x\ntrue\n\n\n\n\n\nskew(œâ::Vec{3})\n\nConstruct a skew-symmetric (anti-symmetric) tensor W from a vector œâ as\n\nbmomega = beginBmatrix\n    omega_1 \n    omega_2 \n    omega_3\nendBmatrix quad\nbmW = beginbmatrix\n     0          -omega_3   omega_2 \n     omega_3  0           -omega_1 \n    -omega_2   omega_1   0\nendbmatrix\n\nExamples\n\njulia> skew(Vec(1,2,3))\n3√ó3 Tensor{Tuple{3, 3}, Int64, 2, 9}:\n  0  -3   2\n  3   0  -1\n -2   1   0\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Tensorial.minorsymmetric","page":"Operations","title":"Tensorial.minorsymmetric","text":"minorsymmetric(::AbstractFourthOrderTensor) -> SymmetricFourthOrderTensor\n\nCompute the minor symmetric part of a fourth order tensor.\n\nExamples\n\njulia> x = rand(Tensor{Tuple{3,3,3,3}});\n\njulia> minorsymmetric(x) ‚âà @einsum (i,j,k,l) -> (x[i,j,k,l] + x[j,i,k,l] + x[i,j,l,k] + x[j,i,l,k]) / 4\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Rotation","page":"Operations","title":"Rotation","text":"","category":"section"},{"location":"Operations/","page":"Operations","title":"Operations","text":"rotmatx\nrotmaty\nrotmatz\nrotmat\nrotate","category":"page"},{"location":"Operations/#Tensorial.rotmatx","page":"Operations","title":"Tensorial.rotmatx","text":"rotmatx(Œ∏::Number)\n\nConstruct rotation matrix around x axis.\n\nbmR_x = beginbmatrix\n1  0  0 \n0  costheta  -sintheta \n0  sintheta   costheta\nendbmatrix\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Tensorial.rotmaty","page":"Operations","title":"Tensorial.rotmaty","text":"rotmaty(Œ∏::Number)\n\nConstruct rotation matrix around y axis.\n\nbmR_y = beginbmatrix\ncostheta  0  sintheta \n0  1  0 \n-sintheta  0  costheta\nendbmatrix\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Tensorial.rotmatz","page":"Operations","title":"Tensorial.rotmatz","text":"rotmatz(Œ∏::Number)\n\nConstruct rotation matrix around z axis.\n\nbmR_z = beginbmatrix\ncostheta  -sintheta  0 \nsintheta   costheta  0 \n0  0  1\nendbmatrix\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Tensorial.rotmat","page":"Operations","title":"Tensorial.rotmat","text":"rotmat(Œ∏::Number)\n\nConstruct 2D rotation matrix.\n\nbmR = beginbmatrix\ncostheta  -sintheta \nsintheta   costheta\nendbmatrix\n\nExamples\n\njulia> rotmat(deg2rad(30))\n2√ó2 Tensor{Tuple{2, 2}, Float64, 2, 4}:\n 0.866025  -0.5\n 0.5        0.866025\n\n\n\n\n\nrotmat(Œ∏::Vec{3}; sequence::Symbol)\n\nConvert Euler angles to rotation matrix. Use 3 characters belonging to the set (X, Y, Z) for intrinsic rotations, or (x, y, z) for extrinsic rotations.\n\nExamples\n\njulia> Œ±, Œ≤, Œ≥ = map(deg2rad, rand(3));\n\njulia> rotmat(Vec(Œ±,Œ≤,Œ≥), sequence = :XYZ) ‚âà rotmatx(Œ±) ‚ãÖ rotmaty(Œ≤) ‚ãÖ rotmatz(Œ≥)\ntrue\n\njulia> rotmat(Vec(Œ±,Œ≤,Œ≥), sequence = :xyz) ‚âà rotmatz(Œ≥) ‚ãÖ rotmaty(Œ≤) ‚ãÖ rotmatx(Œ±)\ntrue\n\njulia> rotmat(Vec(Œ±,Œ≤,Œ≥), sequence = :XYZ) ‚âà rotmat(Vec(Œ≥,Œ≤,Œ±), sequence = :zyx)\ntrue\n\n\n\n\n\nrotmat(a => b)\n\nConstruct rotation matrix rotating vector a to b. The norms of two vectors must be the same.\n\nExamples\n\njulia> a = normalize(rand(Vec{3}))\n3-element Vec{3, Float64}:\n 0.4829957515506539\n 0.8135223859352438\n 0.3238771859304809\n\njulia> b = normalize(rand(Vec{3}))\n3-element Vec{3, Float64}:\n 0.8605677447967596\n 0.3398133016944055\n 0.3794075336718636\n\njulia> R = rotmat(a => b)\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n -0.00540771   0.853773   0.520617\n  0.853773    -0.267108   0.446905\n  0.520617     0.446905  -0.727485\n\njulia> R ‚ãÖ a ‚âà b\ntrue\n\n\n\n\n\nrotmat(Œ∏, n::Vec)\n\nConstruct rotation matrix from angle Œ∏ and axis n.\n\nExamples\n\njulia> x = Vec(1.0, 0.0, 0.0)\n3-element Vec{3, Float64}:\n 1.0\n 0.0\n 0.0\n\njulia> n = Vec(0.0, 0.0, 1.0)\n3-element Vec{3, Float64}:\n 0.0\n 0.0\n 1.0\n\njulia> rotmat(œÄ/2, n) ‚ãÖ x\n3-element Vec{3, Float64}:\n 6.123233995736766e-17\n 1.0\n 0.0\n\n\n\n\n\nrotmat(::Quaternion)\n\nConstruct rotation matrix from quaternion.\n\nExamples\n\njulia> q = quaternion(œÄ/4, Vec(0,0,1))\n0.9238795325112867 + 0.0ùôû + 0.0ùôü + 0.3826834323650898ùô†\n\njulia> rotmat(q)\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.707107  -0.707107  0.0\n 0.707107   0.707107  0.0\n 0.0        0.0       1.0\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Tensorial.rotate","page":"Operations","title":"Tensorial.rotate","text":"rotate(x, R::SecondOrderTensor)\n\nRotate x using the rotation matrix R. This function preserves the symmetry of the matrix.\n\nExamples\n\njulia> R = rotmatz(œÄ/4)\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.707107  -0.707107  0.0\n 0.707107   0.707107  0.0\n 0.0        0.0       1.0\n\njulia> rotate(Vec(1,0,0), R)\n3-element Vec{3, Float64}:\n 0.7071067811865476\n 0.7071067811865475\n 0.0\n\njulia> A = rand(SymmetricSecondOrderTensor{3})\n3√ó3 SymmetricSecondOrderTensor{3, Float64, 6}:\n 0.325977  0.549051  0.218587\n 0.549051  0.894245  0.353112\n 0.218587  0.353112  0.394255\n\njulia> rotate(A, R) ‚âà R ‚ãÖ A ‚ãÖ R'\ntrue\n\n\n\n\n\nrotate(x::Vec, q::Quaternion)\n\nRotate x by quaternion q.\n\nExamples\n\njulia> v = Vec(1.0, 0.0, 0.0)\n3-element Vec{3, Float64}:\n 1.0\n 0.0\n 0.0\n\njulia> rotate(v, quaternion(œÄ/4, Vec(0,0,1)))\n3-element Vec{3, Float64}:\n 0.7071067811865475\n 0.7071067811865476\n 0.0\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Continuum-mechanics","page":"Operations","title":"Continuum mechanics","text":"","category":"section"},{"location":"Operations/","page":"Operations","title":"Operations","text":"vol(::Tensorial.AbstractSquareTensor{3})\ndev(::Tensorial.AbstractSquareTensor{3})\nmean(::Tensorial.AbstractSquareTensor{3})\nvonmises\nstress_invariants\ndeviatoric_stress_invariants","category":"page"},{"location":"Operations/#Tensorial.vol-Tuple{Union{AbstractSecondOrderTensor{3, T}, AbstractSymmetricSecondOrderTensor{3, T}, AbstractMat{3, 3, T}} where T}","page":"Operations","title":"Tensorial.vol","text":"vol(A)\n\nCompute the volumetric part of a square tensor A. This is only available in 3D.\n\nExamples\n\njulia> x = rand(Mat{3,3})\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> vol(x)\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.391113  0.0       0.0\n 0.0       0.391113  0.0\n 0.0       0.0       0.391113\n\njulia> vol(x) + dev(x) ‚âà x\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Operations/#Tensorial.dev-Tuple{Union{AbstractSecondOrderTensor{3, T}, AbstractSymmetricSecondOrderTensor{3, T}, AbstractMat{3, 3, T}} where T}","page":"Operations","title":"Tensorial.dev","text":"dev(::AbstractSecondOrderTensor{3})\ndev(::AbstractSymmetricSecondOrderTensor{3})\n\nCompute the deviatoric part of a square tensor. This is only available in 3D.\n\nExamples\n\njulia> x = rand(Mat{3,3})\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> dev(x)\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n -0.065136   0.894245   0.953125\n  0.549051  -0.0380011  0.795547\n  0.218587   0.394255   0.103137\n\njulia> tr(dev(x))\n5.551115123125783e-17\n\n\n\n\n\n","category":"method"},{"location":"Operations/#Statistics.mean-Tuple{Union{AbstractSecondOrderTensor{3, T}, AbstractSymmetricSecondOrderTensor{3, T}, AbstractMat{3, 3, T}} where T}","page":"Operations","title":"Statistics.mean","text":"mean(A)\n\nCompute the mean value of diagonal entries of a square tensor A.\n\nExamples\n\njulia> x = rand(Mat{3,3})\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> mean(x)\n0.3911127467177425\n\n\n\n\n\n","category":"method"},{"location":"Operations/#Tensorial.vonmises","page":"Operations","title":"Tensorial.vonmises","text":"vonmises(::AbstractSymmetricSecondOrderTensor{3})\n\nCompute the von Mises stress.\n\nq = sqrtfrac32 mathrmdev(bmsigma)  mathrmdev(bmsigma) = sqrt3J_2\n\nExamples\n\njulia> œÉ = rand(SymmetricSecondOrderTensor{3})\n3√ó3 SymmetricSecondOrderTensor{3, Float64, 6}:\n 0.325977  0.549051  0.218587\n 0.549051  0.894245  0.353112\n 0.218587  0.353112  0.394255\n\njulia> vonmises(œÉ)\n1.3078860814690232\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Tensorial.stress_invariants","page":"Operations","title":"Tensorial.stress_invariants","text":"stress_invariants(::AbstractSecondOrderTensor{3})\nstress_invariants(::AbstractSymmetricSecondOrderTensor{3})\nstress_invariants(::Vec{3})\n\nReturn a tuple storing stress invariants.\n\nbeginaligned\nI_1(bmsigma) = mathrmtr(bmsigma) \nI_2(bmsigma) = frac12 (mathrmtr(bmsigma)^2 - mathrmtr(bmsigma^2)) \nI_3(bmsigma) = det(bmsigma)\nendaligned\n\nExamples\n\njulia> œÉ = rand(SymmetricSecondOrderTensor{3})\n3√ó3 SymmetricSecondOrderTensor{3, Float64, 6}:\n 0.325977  0.549051  0.218587\n 0.549051  0.894245  0.353112\n 0.218587  0.353112  0.394255\n\njulia> I‚ÇÅ, I‚ÇÇ, I‚ÇÉ = stress_invariants(œÉ)\n(1.6144775244804341, 0.2986572249840249, -0.0025393241133506677)\n\n\n\n\n\n","category":"function"},{"location":"Operations/#Tensorial.deviatoric_stress_invariants","page":"Operations","title":"Tensorial.deviatoric_stress_invariants","text":"deviatoric_stress_invariants(::AbstractSecondOrderTensor{3})\ndeviatoric_stress_invariants(::AbstractSymmetricSecondOrderTensor{3})\ndeviatoric_stress_invariants(::Vec{3})\n\nReturn a tuple storing deviatoric stress invariants.\n\nbeginaligned\nJ_1(bmsigma) = mathrmtr(mathrmdev(bmsigma)) = 0 \nJ_2(bmsigma) = frac12 mathrmtr(mathrmdev(bmsigma)^2) \nJ_3(bmsigma) = frac13 mathrmtr(mathrmdev(bmsigma)^3)\nendaligned\n\nExamples\n\njulia> œÉ = rand(SymmetricSecondOrderTensor{3})\n3√ó3 SymmetricSecondOrderTensor{3, Float64, 6}:\n 0.325977  0.549051  0.218587\n 0.549051  0.894245  0.353112\n 0.218587  0.353112  0.394255\n\njulia> J‚ÇÅ, J‚ÇÇ, J‚ÇÉ = deviatoric_stress_invariants(œÉ)\n(0.0, 0.5701886673667987, 0.14845380911930367)\n\n\n\n\n\n","category":"function"},{"location":"Benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"Benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The performance for some typical operators is summarized below. For fourth-order tensors, both Array and SArray use the classical Voigt form to correctly handle symmetries. The benchmakrs show that Tensor offers performance comparable to SArray without the hassle of using the Voigt form.","category":"page"},{"location":"Benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"a = rand(Vec{3})\nA = rand(SecondOrderTensor{3})\nS = rand(SymmetricSecondOrderTensor{3})\nAA = rand(FourthOrderTensor{3})\nSS = rand(SymmetricFourthOrderTensor{3})","category":"page"},{"location":"Benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Operation Tensor Array Speedup SArray Speedup\nSingle contraction     \na ‚ãÖ a 3.095 ns 9.257 ns √ó3.0 10.339 ns √ó3.3\nA ‚ãÖ a 3.095 ns 56.540 ns √ó18.0 3.396 ns √ó1.1\nS ‚ãÖ a 3.397 ns 56.234 ns √ó17.0 3.396 ns √ó1.0\nDouble contraction     \nA ‚ä° A 3.406 ns 11.111 ns √ó3.3 3.406 ns √ó1.0\nS ‚ä° S 3.095 ns 10.189 ns √ó3.3 3.406 ns √ó1.1\nAA ‚ä° A 7.733 ns 75.519 ns √ó9.8 7.743 ns √ó1.0\nSS ‚ä° S 4.032 ns 65.875 ns √ó16.0 4.091 ns √ó1.0\nTensor product     \na ‚äó a 3.716 ns 33.154 ns √ó8.9 3.416 ns √ó0.92\nCross product     \na √ó a 3.716 ns 33.154 ns √ó8.9 3.416 ns √ó0.92\nDeterminant     \ndet(A) 3.406 ns 170.118 ns √ó50.0 3.095 ns √ó0.91\ndet(S) 3.095 ns 170.186 ns √ó55.0 3.095 ns √ó1.0\nInverse     \ninv(A) 5.971 ns 474.005 ns √ó79.0 7.420 ns √ó1.2\ninv(S) 4.914 ns 488.448 ns √ó99.0 7.400 ns √ó1.5\ninv(AA) 957.000 ns 1.584 Œºs √ó1.7 963.800 ns √ó1.0\ninv(SS) 377.537 ns 974.545 ns √ó2.6 363.097 ns √ó0.96","category":"page"},{"location":"Benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The benchmarks are generated by runbenchmarks.jl on the following system:","category":"page"},{"location":"Benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"julia> versioninfo()\nJulia Version 1.11.1\nCommit 8f5b7ca12ad (2024-10-16 10:53 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 4 √ó AMD EPYC 7763 64-Core Processor\n  WORD_SIZE: 64\n  LLVM: libLLVM-16.0.6 (ORCJIT, znver3)\nThreads: 1 default, 0 interactive, 1 GC (on 4 virtual cores)\n","category":"page"},{"location":"Constructors/","page":"Constructing tensors","title":"Constructing tensors","text":"DocTestSetup = :(using Tensorial)","category":"page"},{"location":"Constructors/#Constructing-tensors","page":"Constructing tensors","title":"Constructing tensors","text":"","category":"section"},{"location":"Constructors/#From-an-AbstractArray","page":"Constructing tensors","title":"From an AbstractArray","text":"","category":"section"},{"location":"Constructors/","page":"Constructing tensors","title":"Constructing tensors","text":"using Tensorial","category":"page"},{"location":"Constructors/","page":"Constructing tensors","title":"Constructing tensors","text":"Vec{2}([1,2])\nVec{2,Float64}([1,2])\nMat{2,2}([1 2; 3 4])\nMat{2,2,Float64}([1 2; 3 4])\nSymmetricSecondOrderTensor{2}([1 2; 3 4]) # InexactError\nSymmetricSecondOrderTensor{2}([1 2; 2 4])","category":"page"},{"location":"Constructors/#From-a-function","page":"Constructing tensors","title":"From a function","text":"","category":"section"},{"location":"Constructors/","page":"Constructing tensors","title":"Constructing tensors","text":"using Tensorial","category":"page"},{"location":"Constructors/","page":"Constructing tensors","title":"Constructing tensors","text":"Œ¥ = one(Mat{2,2})\nI = SymmetricFourthOrderTensor{2}((i,j,k,l) -> (Œ¥[i,k]*Œ¥[j,l] + Œ¥[i,l]*Œ¥[j,k])/2)\nI == one(SymmetricFourthOrderTensor{2})","category":"page"},{"location":"Constructors/#Identity-tensors","page":"Constructing tensors","title":"Identity tensors","text":"","category":"section"},{"location":"Constructors/","page":"Constructing tensors","title":"Constructing tensors","text":"one","category":"page"},{"location":"Constructors/#Base.one","page":"Constructing tensors","title":"Base.one","text":"one(TensorType)\n\nConstruct an identity tensor. The supported TensorTypes are as follows:\n\nSecondOrderTensor{dim}\nSymmetricSecondOrderTensor{dim}\nFourthOrderTensor{dim}\nSymmetricFourthOrderTensor{dim}\n\njulia> Œ¥ = one(Mat{3,3})\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> one(SymmetricFourthOrderTensor{3}) ‚âà @einsum (i,j,k,l) -> (Œ¥[i,k]*Œ¥[j,l] + Œ¥[i,l]*Œ¥[j,k]) / 2\ntrue\n\n\n\n\n\n","category":"function"},{"location":"Constructors/#Zero-tensors","page":"Constructing tensors","title":"Zero tensors","text":"","category":"section"},{"location":"Constructors/","page":"Constructing tensors","title":"Constructing tensors","text":"zero","category":"page"},{"location":"Constructors/#Base.zero","page":"Constructing tensors","title":"Base.zero","text":"zero(TensorType)\n\nConstruct a zero tensor.\n\njulia> zero(Vec{2})\n2-element Vec{2, Float64}:\n 0.0\n 0.0\n\njulia> zero(Mat{2,3})\n2√ó3 Mat{2, 3, Float64, 6}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"Constructors/#Macros","page":"Constructing tensors","title":"Macros","text":"","category":"section"},{"location":"Constructors/","page":"Constructing tensors","title":"Constructing tensors","text":"@Vec\n@Mat\n@Tensor","category":"page"},{"location":"Constructors/#Tensorial.@Vec","page":"Constructing tensors","title":"Tensorial.@Vec","text":"@Vec [a, b, c, d]\n@Vec [i for i in 1:2]\n@Vec ones(2)\n\nA convenient macro to construct Vec.\n\n\n\n\n\n","category":"macro"},{"location":"Constructors/#Tensorial.@Mat","page":"Constructing tensors","title":"Tensorial.@Mat","text":"@Mat [a b c d]\n@Mat [[a, b];[c, d]]\n@Mat [i+j for i in 1:2, j in 1:2]\n@Mat ones(2, 2)\n\nA convenient macro to construct Mat.\n\n\n\n\n\n","category":"macro"},{"location":"Constructors/#Tensorial.@Tensor","page":"Constructing tensors","title":"Tensorial.@Tensor","text":"@Tensor [a b; c d]\n@Tensor [[a, b];[c, d]]\n@Tensor [i+j for i in 1:2, j in 1:2]\n@Tensor ones(2, 2, 2)\n\nA convenient macro to construct Tensor with arbitrary dimension.\n\n\n\n\n\n","category":"macro"},{"location":"Constructors/#Other-special-tensors","page":"Constructing tensors","title":"Other special tensors","text":"","category":"section"},{"location":"Constructors/#Levi-Civita","page":"Constructing tensors","title":"Levi-Civita","text":"","category":"section"},{"location":"Constructors/","page":"Constructing tensors","title":"Constructing tensors","text":"levicivita","category":"page"},{"location":"Constructors/#Tensorial.levicivita","page":"Constructing tensors","title":"Tensorial.levicivita","text":"levicivita(::Val{N} = Val(3))\n\nReturn N dimensional Levi-Civita tensor.\n\nExamples\n\njulia> œµ = levicivita()\n3√ó3√ó3 Tensor{Tuple{3, 3, 3}, Int64, 3, 27}:\n[:, :, 1] =\n 0   0  0\n 0   0  1\n 0  -1  0\n\n[:, :, 2] =\n 0  0  -1\n 0  0   0\n 1  0   0\n\n[:, :, 3] =\n  0  1  0\n -1  0  0\n  0  0  0\n\n\n\n\n\n","category":"function"},{"location":"Broadcast/#Broadcast","page":"Broadcast","title":"Broadcast","text":"","category":"section"},{"location":"Broadcast/","page":"Broadcast","title":"Broadcast","text":"In Tensorial.jl, Tensor behaves like a scalar rather than an Array when performing broadcasting, as follows:","category":"page"},{"location":"Broadcast/","page":"Broadcast","title":"Broadcast","text":"using Tensorial","category":"page"},{"location":"Broadcast/","page":"Broadcast","title":"Broadcast","text":"x = Vec(1,2,3)\nV = [Vec{3}(i:i+2) for i in 1:4]\nx .+ V\nV .= zero(x)","category":"page"},{"location":"Broadcast/","page":"Broadcast","title":"Broadcast","text":"Conversely, broadcasting a Tensor itself or with scalars and tuples behaves the same as built-in Array, as shown below:","category":"page"},{"location":"Broadcast/","page":"Broadcast","title":"Broadcast","text":"using Tensorial","category":"page"},{"location":"Broadcast/","page":"Broadcast","title":"Broadcast","text":"x = Vec(1,2,3)\nsqrt.(x)\nx .+ 2\nx .+ (2,3,4)","category":"page"},{"location":"#Tensorial.jl","page":"Home","title":"Tensorial.jl","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tensorial.jl provides statically sized Tensor which is compatible with the AbstractArray, similar to the SArray in StaticArrays.jl. In addition to the basic operations for AbstractArray, the package also offers a tensorial interface and several powerful features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Contraction, tensor product (‚äó), and a flexible @einsum macro for Einstein summation convention\nA @Symmetry macro to define the tensor symmetries, which eliminates unnecessary calculations\nAutomatic differentiation through gradient and hessian functions\nPerformance comparable to SArray (see benchmarks)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add Tensorial","category":"page"},{"location":"#Other-tensor-packages","page":"Home","title":"Other tensor packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Einsum.jl\nTensorOprations.jl\nTensors.jl","category":"page"},{"location":"#Inspiration","page":"Home","title":"Inspiration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"StaticArrays.jl\nTensors.jl","category":"page"},{"location":"Automatic differentiation/#Automatic-differentiation","page":"Automatic differentiation","title":"Automatic differentiation","text":"","category":"section"},{"location":"Automatic differentiation/","page":"Automatic differentiation","title":"Automatic differentiation","text":"warn: Warn\nThe user must provide the appropriate tensor symmetry information; otherwise, automatic differentiation may return unexpected values. In the following example, even with identical tensor values, the results vary depending on the Tensor type.using TensorialA = rand(Mat{3,3})\nS = A ‚ãÖ A' # `S` is symmetric but not of the type `SymmetricSecondOrderTensor`\ngradient(identity, S) ‚âà one(FourthOrderTensor{3})\ngradient(identity, symmetric(S)) ‚âà one(SymmetricFourthOrderTensor{3})","category":"page"},{"location":"Automatic differentiation/","page":"Automatic differentiation","title":"Automatic differentiation","text":"gradient\nhessian","category":"page"},{"location":"Automatic differentiation/#Tensorial.gradient","page":"Automatic differentiation","title":"Tensorial.gradient","text":"gradient(f, x)\ngradient(f, x, :all)\n\nCompute the gradient of f with respect to x by the automatic differentiation. If pseudo keyword :all is given, the value of f(x) is also returned.\n\nExamples\n\njulia> x = rand(Mat{3,3})\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 0.325977  0.894245  0.953125\n 0.549051  0.353112  0.795547\n 0.218587  0.394255  0.49425\n\njulia> gradient(tr, x)\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> ‚àáf, f = gradient(tr, x, :all)\n([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0], 1.1733382401532275)\n\n\n\n\n\n","category":"function"},{"location":"Automatic differentiation/#Tensorial.hessian","page":"Automatic differentiation","title":"Tensorial.hessian","text":"hessian(f, x)\nhessian(f, x, :all)\n\nCompute the hessian of f with respect to x by the automatic differentiation. If pseudo keyword :all is given, the value of f(x) is also returned.\n\nExamples\n\njulia> x = rand(Vec{3})\n3-element Vec{3, Float64}:\n 0.32597672886359486\n 0.5490511363155669\n 0.21858665481883066\n\njulia> hessian(norm, x)\n3√ó3 Tensor{Tuple{3, 3}, Float64, 2, 9}:\n  1.13603   -0.582196  -0.231782\n -0.582196   0.501079  -0.390397\n -0.231782  -0.390397   1.32626\n\njulia> ‚àá‚àáf, ‚àáf, f = hessian(norm, x, :all)\n([1.1360324375454411 -0.5821964220304534 -0.23178236037013888; -0.5821964220304533 0.5010791569244991 -0.39039709608344814; -0.23178236037013886 -0.39039709608344814 1.3262640626479867], [0.4829957515506539, 0.8135223859352438, 0.3238771859304809], 0.6749059962060727)\n\n\n\n\n\n","category":"function"}]
}
