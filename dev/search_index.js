var documenterSearchIndex = {"docs":
[{"location":"Tensor Type/#Tensor-type","page":"Tensor type","title":"Tensor type","text":"","category":"section"},{"location":"Tensor Type/#Type-parameters","page":"Tensor type","title":"Type parameters","text":"","category":"section"},{"location":"Tensor Type/","page":"Tensor type","title":"Tensor type","text":"All tensors are represented by a type Tensor{S, T, N, L} where each type parameter represents following:","category":"page"},{"location":"Tensor Type/","page":"Tensor type","title":"Tensor type","text":"S: The size of Tensors which is specified by using Tuple (e.g., 3x2 tensor becomes Tensor{Tuple{3,2}}).\nT: The type of element which must be T <: Real.\nN: The number of dimensions (the order of tensor).\nL: The number of independent components.","category":"page"},{"location":"Tensor Type/","page":"Tensor type","title":"Tensor type","text":"Basically, the type parameters N and L do not need to be specified for constructing tensors because it can be inferred from the size of tensor S.","category":"page"},{"location":"Tensor Type/#Symmetry","page":"Tensor type","title":"Symmetry","text":"","category":"section"},{"location":"Tensor Type/","page":"Tensor type","title":"Tensor type","text":"If possible, specifying the symmetry of the tensor is good for performance since Tensorial.jl provides the optimal computations. The symmetries can be applied using Symmetry in type parameter S (e.g., Symmetry{Tuple{3,3}}). @Symmetry macro can omit Tuple like @Symmetry{2,2}. The following are examples to specify symmetries:","category":"page"},{"location":"Tensor Type/","page":"Tensor type","title":"Tensor type","text":"A_(ij) with 3x3: Tensor{Tuple{@Symmetry{3,3}}}\nA_(ij)k with 3x3x2: Tensor{Tuple{@Symmetry{3,3}, 2}}\nA_(ijk) with 3x3x3: Tensor{Tuple{@Symmetry{3,3,3}}}\nA_(ij)(kl) with 3x3x3x3: Tensor{Tuple{@Symmetry{3,3}, @Symmetry{3,3}}}","category":"page"},{"location":"Tensor Type/","page":"Tensor type","title":"Tensor type","text":"where the bracket () in indices denotes the symmetry.","category":"page"},{"location":"Cheat Sheet/#Cheat-Sheet","page":"Cheat Sheet","title":"Cheat Sheet","text":"","category":"section"},{"location":"Cheat Sheet/#Constructors","page":"Cheat Sheet","title":"Constructors","text":"","category":"section"},{"location":"Cheat Sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"# identity tensors\none(Tensor{Tuple{3,3}})            == Matrix(I,3,3) # second-order identity tensor\none(Tensor{Tuple{@Symmetry{3,3}}}) == Matrix(I,3,3) # symmetric second-order identity tensor\nI  = one(Tensor{NTuple{4,3}})               # fourth-order identity tensor\nIs = one(Tensor{NTuple{2, @Symmetry{3,3}}}) # symmetric fourth-order identity tensor\n\n# zero tensors\nzero(Tensor{Tuple{2,3}}) == zeros(2, 3)\nzero(Tensor{Tuple{@Symmetry{3,3}}}) == zeros(3, 3)\n\n# random tensors\nrand(Tensor{Tuple{2,3}})\nrandn(Tensor{Tuple{2,3}})\n\n# from arrays\nTensor{Tuple{2,2}}([1 2; 3 4]) == [1 2; 3 4]\nTensor{Tuple{@Symmetry{2,2}}}([1 2; 3 4]) == [1 3; 3 4] # lower triangular part is used\n\n# from functions\nTensor{Tuple{2,2}}((i,j) -> i == j ? 1 : 0) == one(Tensor{Tuple{2,2}})\nTensor{Tuple{@Symmetry{2,2}}}((i,j) -> i == j ? 1 : 0) == one(Tensor{Tuple{@Symmetry{2,2}}})\n\n# macros (same interface as StaticArrays.jl)\n@Vec [1,2,3]\n@Vec rand(4)\n@Mat [1 2\n      3 4]\n@Mat rand(4,4)\n@Tensor rand(2,2,2)","category":"page"},{"location":"Cheat Sheet/#Tensor-Operations","page":"Cheat Sheet","title":"Tensor Operations","text":"","category":"section"},{"location":"Cheat Sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"# 2nd-order vs. 2nd-order\nx = rand(Tensor{Tuple{2,2}})\ny = rand(Tensor{Tuple{@Symmetry{2,2}}})\nx ⊗ y isa Tensor{Tuple{2,2,@Symmetry{2,2}}} # tensor product\nx ⋅ y isa Tensor{Tuple{2,2}}                # single contraction (x_ij * y_jk)\nx ⊡ y isa Real                              # double contraction (x_ij * y_ij)\n\n# 3rd-order vs. 1st-order\nA = rand(Tensor{Tuple{@Symmetry{2,2},2}})\nv = rand(Vec{2})\nA ⊗ v isa Tensor{Tuple{@Symmetry{2,2},2,2}} # A_ijk * v_l\nA ⋅ v isa Tensor{Tuple{@Symmetry{2,2}}}     # A_ijk * v_k\nA ⊡ v # error\n\n# 4th-order vs. 2nd-order\nII = one(SymmetricFourthOrderTensor{2}) # equal to one(Tensor{Tuple{@Symmetry{2,2}, @Symmetry{2,2}}})\nA = rand(Tensor{Tuple{2,2}})\nS = rand(Tensor{Tuple{@Symmetry{2,2}}})\nII ⊡ A == (A + A') / 2 == symmetric(A) # symmetrizing A, resulting in Tensor{Tuple{@Symmetry{2,2}}}\nII ⊡ S == S\n\n# contraction\nx = rand(Tensor{Tuple{2,2,2}})\ny = rand(Tensor{Tuple{2,@Symmetry{2,2}}})\ncontraction(x, y, Val(1)) isa Tensor{Tuple{2,2, @Symmetry{2,2}}}     # single contraction (== ⋅)\ncontraction(x, y, Val(2)) isa Tensor{Tuple{2,2}}                     # double contraction (== ⊡)\ncontraction(x, y, Val(3)) isa Real                                   # triple contraction (x_ijk * y_ijk)\ncontraction(x, y, Val(0)) isa Tensor{Tuple{2,2,2,2, @Symmetry{2,2}}} # tensor product (== ⊗)\n\n# norm/tr/mean/vol/dev\nx = rand(SecondOrderTensor{3}) # equal to rand(Tensor{Tuple{3,3}})\nv = rand(Vec{3})\nnorm(v)\ntr(x)\nmean(x) == tr(x) / 3 # useful for computing mean stress\nvol(x) + dev(x) == x # decomposition into volumetric part and deviatoric part\n\n# det/inv for 2nd-order tensor\nA = rand(SecondOrderTensor{3})          # equal to one(Tensor{Tuple{3,3}})\nS = rand(SymmetricSecondOrderTensor{3}) # equal to one(Tensor{Tuple{@Symmetry{3,3}}})\ndet(A); det(S)\ninv(A) ⋅ A ≈ one(A)\ninv(S) ⋅ S ≈ one(S)\n\n# inv for 4th-order tensor\nAA = rand(FourthOrderTensor{3})          # equal to one(Tensor{Tuple{3,3,3,3}})\nSS = rand(SymmetricFourthOrderTensor{3}) # equal to one(Tensor{Tuple{@Symmetry{3,3}, @Symmetry{3,3}}})\ninv(AA) ⊡ AA ≈ one(AA)\ninv(SS) ⊡ SS ≈ one(SS)","category":"page"},{"location":"Cheat Sheet/#Automatic-differentiation","page":"Cheat Sheet","title":"Automatic differentiation","text":"","category":"section"},{"location":"Cheat Sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"# Real -> Real\ngradient(x -> 2x^2 + x + 3, 3) == (x = 3; 4x + 1)\ngradient(x -> 2.0, 3) == 0.0\n\n# Real -> Tensor\ngradient(x -> Tensor{Tuple{2,2}}((i,j) -> i*x^2), 3) == (x = 3; Tensor{Tuple{2,2}}((i,j) -> 2i*x))\ngradient(x -> one(Tensor{Tuple{2,2}}), 3) == zero(Tensor{Tuple{2,2}})\n\n# Tensor -> Real\ngradient(tr, rand(Tensor{Tuple{3,3}})) == one(Tensor{Tuple{3,3}})\n\n# Tensor -> Tensor\nA = rand(Tensor{Tuple{3,3}})\nD  = gradient(dev, A)            # deviatoric projection tensor\nDs = gradient(dev, symmetric(A)) # symmetric deviatoric projection tensor\nA ⊡ D  ≈ dev(A)\nA ⊡ Ds ≈ symmetric(dev(A))\ngradient(identity, A)  == one(FourthOrderTensor{3})          # 4th-order identity tensor\ngradient(symmetric, A) == one(SymmetricFourthOrderTensor{3}) # symmetric 4th-order identity tensor","category":"page"},{"location":"Cheat Sheet/#Aliases","page":"Cheat Sheet","title":"Aliases","text":"","category":"section"},{"location":"Cheat Sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"const SecondOrderTensor{dim, T, L} = Tensor{NTuple{2, dim}, T, 2, L}\nconst FourthOrderTensor{dim, T, L} = Tensor{NTuple{4, dim}, T, 4, L}\nconst SymmetricSecondOrderTensor{dim, T, L} = Tensor{Tuple{@Symmetry{dim, dim}}, T, 2, L}\nconst SymmetricFourthOrderTensor{dim, T, L} = Tensor{NTuple{2, @Symmetry{dim, dim}}, T, 4, L}\nconst Mat{m, n, T, L} = Tensor{Tuple{m, n}, T, 2, L}\nconst Vec{dim, T} = Tensor{Tuple{dim}, T, 1, dim}","category":"page"},{"location":"Tensor Operations/","page":"Tensor Operations","title":"Tensor Operations","text":"DocTestSetup = :(using Tensorial)","category":"page"},{"location":"Tensor Operations/#Tensor-Operations","page":"Tensor Operations","title":"Tensor Operations","text":"","category":"section"},{"location":"Tensor Operations/","page":"Tensor Operations","title":"Tensor Operations","text":"Order = [:function]\nPages = [\"Tensor Operations.md\"]","category":"page"},{"location":"Tensor Operations/","page":"Tensor Operations","title":"Tensor Operations","text":"Modules = [Tensorial]\nOrder   = [:function]\nPages   = [\"ops.jl\"]","category":"page"},{"location":"Tensor Operations/#LinearAlgebra.dot-Tuple{Tensor,Tensor}","page":"Tensor Operations","title":"LinearAlgebra.dot","text":"dot(x::Tensor, y::Tensor)\nx ⋅ y\n\nCompute dot product such as a = x_i y_i. This is equivalent to contraction(::Tensor, ::Tensor, Val(1)). x ⋅ y (where ⋅ can be typed by \\cdot<tab>) is a synonym for cdot(x, y).\n\nExamples\n\njulia> x = rand(Vec{3});\n\njulia> y = rand(Vec{3});\n\njulia> a = x ⋅ y\n1.3643452781654775\n\n\n\n\n\n","category":"method"},{"location":"Tensor Operations/#Tensorial.contraction-Union{Tuple{N}, Tuple{Tensor,Tensor,Val{N}}} where N","page":"Tensor Operations","title":"Tensorial.contraction","text":"contraction(::Tensor, ::Tensor, ::Val{N})\n\nConduct contraction of N inner indices. For example, N=2 contraction for third-order tensors A_ij = B_ikl C_klj can be computed in Tensorial.jl as\n\njulia> B = rand(Tensor{Tuple{3,3,3}});\n\njulia> C = rand(Tensor{Tuple{3,3,3}});\n\njulia> A = contraction(B, C, Val(2))\n3×3 Tensor{Tuple{3,3},Float64,2,9}:\n 1.36912   1.86751  1.32531\n 1.61744   2.34426  1.94101\n 0.929252  1.89656  1.79015\n\nFollowing symbols are also available for specific contractions:\n\nx ⊗ y (where ⊗ can be typed by \\otimes<tab>): contraction(x, y, Val(0))\nx ⋅ y (where ⋅ can be typed by \\cdot<tab>): contraction(x, y, Val(1))\nx ⊡ y (where ⊡ can be typed by \\boxdot<tab>): contraction(x, y, Val(2))\n\n\n\n\n\n","category":"method"},{"location":"Tensor Operations/#Tensorial.otimes-Tuple{Tensor,Tensor}","page":"Tensor Operations","title":"Tensorial.otimes","text":"otimes(x::Tensor, y::Tensor)\nx ⊗ y\n\nCompute tensor product such as A_ij = x_i y_j. x ⊗ y (where ⊗ can be typed by \\otimes<tab>) is a synonym for otimes(x, y).\n\nExamples\n\njulia> x = rand(Vec{3});\n\njulia> y = rand(Vec{3});\n\njulia> A = x ⊗ y\n3×3 Tensor{Tuple{3,3},Float64,2,9}:\n 0.271839  0.469146  0.504668\n 0.352792  0.608857  0.654957\n 0.260518  0.449607  0.48365\n\n\n\n\n\n","category":"method"},{"location":"Tensor Operations/#Tensorial.rotmat-Tuple{Real}","page":"Tensor Operations","title":"Tensorial.rotmat","text":"rotmat(θ::Real)\n\nConstruct 2D rotation matrix.\n\nExamples\n\njulia> rotmat(deg2rad(30))\n2×2 Tensor{Tuple{2,2},Float64,2,4}:\n 0.866025  -0.5\n 0.5        0.866025\n\n\n\n\n\n","category":"method"},{"location":"Tensor Operations/#Tensorial.rotmat-Tuple{Tensor{Tuple{3},T,1,3} where T}","page":"Tensor Operations","title":"Tensorial.rotmat","text":"rotmat(θ::Vec{3})\nrotmatx(α::Real)\nrotmaty(β::Real)\nrotmatz(γ::Real)\n\nConvert Euler angles to rotation matrix.\n\nExamples\n\njulia> rotmatx(deg2rad(30))\n3×3 Tensor{Tuple{3,3},Float64,2,9}:\n 1.0  0.0        0.0\n 0.0  0.866025  -0.5\n 0.0  0.5        0.866025\n\n\n\n\n\n","category":"method"},{"location":"#Tensorial","page":"Home","title":"Tensorial","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides symbolic operations for tensors written in Julia. The main motivation behind the development of this package is to provide useful tensor operations (e.g., contraction; tensor product, ⊗; inv; etc.) for arbitrary order and size of tensors. The symmetry of the tensor is also supported for fast computations. The way to give size of the tensor is similar to StaticArrays.jl, except that symmetry can be specified by Symmetry. For example, symmetric fourth-order tensor can be represented as Tensor{Tuple{@Symmetry{3,3}, @Symmetry{3,3}}}. All of these tensors can also be used in provided automatic differentiation functions.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add Tensorial","category":"page"},{"location":"#Other-tensor-packages","page":"Home","title":"Other tensor packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Einsum.jl\nTensorOprations.jl\nTensors.jl","category":"page"},{"location":"#Inspiration","page":"Home","title":"Inspiration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"StaticArrays.jl\nTensors.jl","category":"page"}]
}
